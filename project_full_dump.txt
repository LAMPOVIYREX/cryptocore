# ПОЛНЫЙ ДАМП ПРОЕКТА CRYPTOCORE
# Дата создания: Вс 07 дек 2025 20:06:37 MSK
==============================================\n
## СТРУКТУРА ПРОЕКТА
```
.
├── bin
│   └── cryptocore
├── include
│   ├── hash
│   │   ├── sha256.h
│   │   └── sha3_256.h
│   ├── modes
│   │   └── ecb.h
│   ├── cli_parser.h
│   ├── common.h
│   ├── crypto.h
│   ├── csprng.h
│   ├── file_io.h
│   ├── hash.h
│   └── types.h
├── obj
│   ├── tests
│   │   ├── test_csprng.o
│   │   └── test_roundtrip.o
│   ├── cli_parser.o
│   ├── crypto.o
│   ├── csprng.o
│   ├── file_io.o
│   ├── main.o
│   └── modes.o
├── src
│   ├── hash
│   │   ├── sha256.c
│   │   └── sha3_256.c
│   ├── modes
│   │   └── ecb.c
│   ├── cli_parser.c
│   ├── crypto.c
│   ├── csprng.c
│   ├── file_io.c
│   ├── hash.c
│   ├── main.c
│   └── modes.c
├── tests
│   ├── bin
│   │   ├── test_csprng
│   │   └── test_roundtrip
│   ├── data
│   │   ├── test_files
│   │   │   ├── debug_test.txt
│   │   │   ├── test_15_bytes.txt
│   │   │   ├── test_16_bytes.txt
│   │   │   ├── test_16.txt
│   │   │   ├── test1.txt
│   │   │   └── test2.txt
│   │   ├── decrypted.txt
│   │   ├── plain.txt
│   │   ├── test_15_bytes.txt
│   │   └── test_16_bytes.txt
│   ├── hash
│   ├── results
│   │   ├── nist_reports
│   │   ├── csprng_test.log
│   │   ├── integration_roundtrip.log
│   │   └── roundtrip_test.log
│   ├── scripts
│   │   ├── debug_test.sh
│   │   ├── fixed_interop_test.sh
│   │   ├── openssl_safe_test.sh
│   │   ├── padding_test.sh
│   │   ├── run_all_tests.sh
│   │   ├── run_nist_tests.sh
│   │   ├── run_tests.sh
│   │   ├── safe_test.sh
│   │   ├── test_interoperability.sh
│   │   ├── test_key_generation.sh
│   │   └── test_roundtrip.sh
│   └── src
│       ├── test_csprng.c
│       ├── test_hash.c
│       ├── test_hash_requirements.c
│       └── test_roundtrip.c
├── create_dump.sh
├── decrypted_ecb.txt
├── decrypted.txt
├── Makefile
├── project_full_dump.txt
├── README.md
└── secret.txt

18 directories, 66 files
```

## README.md
```markdown
# CryptoCore

A command-line tool for AES encryption and decryption supporting multiple modes of operation (ECB, CBC, CFB, OFB, CTR) and cryptographic hash functions (SHA-256, SHA3-256).

## Features

- **Encryption/Decryption**:
  - **Algorithms**: AES-128
  - **Modes**: ECB, CBC, CFB, OFB, CTR  
  - **Padding**: PKCS#7 (for ECB and CBC modes)
  - **Key Management**: Automatic secure key generation or hexadecimal input
  - **IV Handling**: Automatic generation for encryption, file-based or argument for decryption
  - **Security**: Cryptographically secure random number generation using OpenSSL RAND_bytes

- **Hashing (Sprint 4)**:
  - **SHA-256**: Implemented from scratch following NIST FIPS 180-4
  - **SHA3-256**: Using OpenSSL's implementation
  - **File Support**: Handles files of any size with streaming processing
  - **Output Format**: Standard hash format compatible with system tools

## Build Instructions

### Prerequisites

- GCC compiler
- OpenSSL development libraries

### On Ubuntu/Debian:
```bash
sudo apt-get update
sudo apt-get install build-essential libssl-dev openssl xxd

Build:
bash
make
Usage
Encryption/Decryption
Encryption with auto-generated key:
bash
./bin/cryptocore -algorithm aes -mode cbc -encrypt -input plain.txt -output cipher.bin
The tool will generate a secure random key and display it:

text
Generated random key: 1a2b3c4d5e6f7890fedcba9876543210
Success: plain.txt -> cipher.bin
Generated IV: aabbccddeeff00112233445566778899
Encryption with specific key:
bash
./bin/cryptocore -algorithm aes -mode cbc -encrypt -key 00112233445566778899aabbccddeeff -input plain.txt -output cipher.bin
Decryption:
bash
./bin/cryptocore -algorithm aes -mode cbc -decrypt -key 00112233445566778899aabbccddeeff -input cipher.bin -output decrypted.txt
Hashing (Sprint 4)
Basic hash computation:
bash
./bin/cryptocore dgst --algorithm sha256 --input document.pdf
Hash with output to file:
bash
./bin/cryptocore dgst --algorithm sha3-256 --input backup.tar --output backup.sha3
Verify against system tools:
bash
./bin/cryptocore dgst --algorithm sha256 --input test.txt > my_hash.txt
sha256sum test.txt > system_hash.txt
diff my_hash.txt system_hash.txt
Supported Modes
Encryption Modes:
ecb - Electronic Codebook (no IV)

cbc - Cipher Block Chaining

cfb - Cipher Feedback

ofb - Output Feedback

ctr - Counter

Hash Algorithms:
sha256 - SHA-256 (implemented from scratch)

sha3-256 - SHA3-256 (using OpenSSL)

Key and IV Format
Keys: 16-byte hexadecimal strings (32 hex characters)

IVs: 16-byte hexadecimal strings (32 hex characters)

No @ prefix required - use plain hex strings

CSPRNG Security
The tool uses OpenSSL's RAND_bytes() for cryptographically secure random number generation, which:

Uses /dev/urandom on Unix systems

Provides cryptographically strong randomness

Is suitable for cryptographic key generation

Hashing Implementation
SHA-256:
Implemented from scratch following NIST FIPS 180-4

Uses Merkle-Damgård construction with 512-bit blocks

Processes files in chunks for memory efficiency

Passes NIST test vectors

SHA3-256:
Uses OpenSSL's EVP interface

Based on Keccak sponge construction

Interoperable with system sha3sum tool

Testing
Run all tests:
bash
make test
Run specific test suites:
bash
# Unit tests
make csprng_test
make roundtrip_test
make hash_test

# Integration tests
./tests/scripts/test_roundtrip.sh
./tests/scripts/test_interoperability.sh
./tests/scripts/test_key_generation.sh
Hash function tests:
bash
make hash_test
./tests/bin/test_hash
NIST Statistical Test Suite:
bash
make nist_test
# Follow instructions to run NIST STS
Examples
File Encryption and Decryption:
bash
# Encrypt with random key
./bin/cryptocore -algorithm aes -mode ctr -encrypt -input secret.txt -output secret.enc

# Decrypt with the generated key
./bin/cryptocore -algorithm aes -mode ctr -decrypt -key <generated_key> -input secret.enc -output secret_decrypted.txt
File Integrity Verification:
bash
# Compute hash
./bin/cryptocore dgst --algorithm sha256 --input important_document.pdf > document.sha256

# Later verify
./bin/cryptocore dgst --algorithm sha256 --input important_document.pdf > check.sha256
diff document.sha256 check.sha256
Interoperability with OpenSSL:
bash
# Encrypt with CryptoCore, decrypt with OpenSSL
./bin/cryptocore -algorithm aes -mode cbc -encrypt -key 00112233445566778899aabbccddeeff -input plain.txt -output cc_cipher.bin
openssl enc -aes-128-cbc -d -K 00112233445566778899aabbccddeeff -in cc_cipher.bin -out openssl_decrypted.txt
Project Structure
text
cryptocore/
├── bin/                    # Compiled binaries
├── include/               # Header files
│   ├── hash/             # Hash function headers
│   ├── modes/            # Encryption mode headers
│   └── *.h               # Other headers
├── src/                  # Source code
│   ├── hash/             # Hash implementations
│   ├── modes/            # Encryption mode implementations
│   └── *.c               # Other source files
├── tests/                # Test files
│   ├── bin/              # Test binaries
│   ├── data/             # Test data
│   ├── results/          # Test results
│   ├── scripts/          # Test scripts
│   └── src/              # Test source code
├── Makefile              # Build system
└── README.md             # This file
Security Notes
Generated keys are displayed only once - save them securely

The tool warns about potentially weak user-provided keys

IVs are automatically generated using CSPRNG for encryption

For decryption, IVs can be read from file or provided via command line

Hash functions process files in chunks to handle large files efficiently

Hashing Support (Sprint 4)
CryptoCore now supports cryptographic hash functions for data integrity verification.

Available Hash Algorithms
SHA-256 - Implemented from scratch following NIST FIPS 180-4

SHA3-256 - Using OpenSSL's implementation

Output Format
The tool outputs hashes in the standard format:

text
HASH_VALUE  INPUT_FILE_PATH
Examples
bash
# Verify against system tools
./bin/cryptocore dgst --algorithm sha256 --input test.txt > my_hash.txt
sha256sum test.txt > system_hash.txt
diff my_hash.txt system_hash.txt

# Empty file test (SHA-256 of empty string):
echo -n "" | ./bin/cryptocore dgst --algorithm sha256 --input -
# Output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  -
Testing Hash Functions
Run the hash function tests:

bash
make test_hash_build
./tests/bin/test_hash
Implementation Notes
SHA-256 is implemented from scratch (no external dependencies)

SHA3-256 uses OpenSSL's EVP interface

Both implementations support files of any size (streaming processing)

All hash functions pass NIST test vectors

License
This project is for educational purposes as part of a cryptography course.

Acknowledgments
NIST for cryptographic standards

OpenSSL project for cryptographic libraries

Course instructors for guidance and requirements```

## MAKEFILE
```makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -O2 -I./include -I./include/hash
LDFLAGS = -lcrypto -lssl

# Основные директории
SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin
INC_DIR = include
HASH_INC_DIR = include/hash

# Директории для тестов
TEST_SRC_DIR = tests/src
TEST_BIN_DIR = tests/bin
TEST_OBJ_DIR = obj/tests
TEST_DATA_DIR = tests/data
TEST_SCRIPTS_DIR = tests/scripts
TEST_RESULTS_DIR = tests/results

# Основные исходные файлы (существующие)
MAIN_SRCS = $(wildcard $(SRC_DIR)/*.c)
MODE_SRCS = $(wildcard $(SRC_DIR)/modes/*.c)
HASH_SRCS = $(wildcard $(SRC_DIR)/hash/*.c)

# Все исходные файлы
ALL_SRCS = $(MAIN_SRCS) $(MODE_SRCS) $(HASH_SRCS)

# Объектные файлы
MAIN_OBJS = $(MAIN_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
MODE_OBJS = $(MODE_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
HASH_OBJS = $(HASH_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# Все объектные файлы
OBJS = $(MAIN_OBJS) $(MODE_OBJS) $(HASH_OBJS)

# Целевой бинарник
TARGET = $(BIN_DIR)/cryptocore

# Тестовые файлы
TEST_SRCS = $(wildcard $(TEST_SRC_DIR)/*.c)
TEST_OBJS = $(TEST_SRCS:$(TEST_SRC_DIR)/%.c=$(TEST_OBJ_DIR)/%.o)
TEST_TARGETS = $(TEST_BIN_DIR)/test_csprng $(TEST_BIN_DIR)/test_roundtrip $(TEST_BIN_DIR)/test_hash $(TEST_BIN_DIR)/test_hash_requirements

# Имена отдельных тестовых целей
TEST_CSPRNG_SRC = $(TEST_SRC_DIR)/test_csprng.c
TEST_CSPRNG_OBJ = $(TEST_OBJ_DIR)/test_csprng.o
TEST_CSPRNG_TARGET = $(TEST_BIN_DIR)/test_csprng

TEST_ROUNDTRIP_SRC = $(TEST_SRC_DIR)/test_roundtrip.c
TEST_ROUNDTRIP_OBJ = $(TEST_OBJ_DIR)/test_roundtrip.o
TEST_ROUNDTRIP_TARGET = $(TEST_BIN_DIR)/test_roundtrip

TEST_HASH_SRC = $(TEST_SRC_DIR)/test_hash.c
TEST_HASH_OBJ = $(TEST_OBJ_DIR)/test_hash.o
TEST_HASH_TARGET = $(TEST_BIN_DIR)/test_hash

TEST_HASH_REQ_SRC = tests/src/test_hash_requirements.c
TEST_HASH_REQ_OBJ = obj/tests/test_hash_requirements.o
TEST_HASH_REQ_TARGET = tests/bin/test_hash_requirements

# Основные объектные файлы без main.o (для линковки тестов)
MAIN_OBJ = $(OBJ_DIR)/main.o
LIB_OBJS = $(filter-out $(MAIN_OBJ), $(OBJS))

# Phony targets
.PHONY: all clean install-dependencies test test_build run_tests \
        nist_test csprng_test roundtrip_test hash_test hash_req_test help

# Default target
all: $(TARGET) test_build

help:
	@echo "Available targets:"
	@echo "  all              - Build main binary and tests (default)"
	@echo "  $(TARGET)        - Build only main binary"
	@echo "  test_build       - Build only test binaries"
	@echo "  test             - Run all unit tests"
	@echo "  hash_test        - Run only basic hash function tests"
	@echo "  hash_req_test    - Run hash requirements tests (avalanche, interoperability)"
	@echo "  run_tests        - Run all tests (unit + integration)"
	@echo "  csprng_test      - Run only CSPRNG tests"
	@echo "  roundtrip_test   - Run only round-trip tests"
	@echo "  nist_test        - Generate data for NIST tests"
	@echo "  clean            - Remove all build artifacts"
	@echo "  install-dependencies - Install required dependencies"
	@echo "  help             - Show this help message"

# Основной бинарник
$(TARGET): $(OBJS) | $(BIN_DIR)
	$(CC) $(OBJS) -o $@ $(LDFLAGS)
	@echo "✓ Built main binary: $@"

# Правило для основных объектных файлов
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "  Compiled: $<"

# Правило для hash объектных файлов
$(OBJ_DIR)/hash/%.o: $(SRC_DIR)/hash/%.c | $(OBJ_DIR)/hash
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "  Compiled: $<"

# Правило для modes объектных файлов
$(OBJ_DIR)/modes/%.o: $(SRC_DIR)/modes/%.c | $(OBJ_DIR)/modes
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "  Compiled: $<"

# Сборка тестовых бинарников
test_build: $(TEST_TARGETS)

$(TEST_CSPRNG_TARGET): $(TEST_CSPRNG_OBJ) $(LIB_OBJS) | $(TEST_BIN_DIR)
	$(CC) $(TEST_CSPRNG_OBJ) $(LIB_OBJS) -o $@ $(LDFLAGS)
	@echo "✓ Built test: $@"

$(TEST_ROUNDTRIP_TARGET): $(TEST_ROUNDTRIP_OBJ) $(LIB_OBJS) | $(TEST_BIN_DIR)
	$(CC) $(TEST_ROUNDTRIP_OBJ) $(LIB_OBJS) -o $@ $(LDFLAGS)
	@echo "✓ Built test: $@"

$(TEST_HASH_TARGET): $(TEST_HASH_OBJ) $(LIB_OBJS) | $(TEST_BIN_DIR)
	$(CC) $(TEST_HASH_OBJ) $(LIB_OBJS) -o $@ $(LDFLAGS)
	@echo "✓ Built test: $@"

$(TEST_HASH_REQ_TARGET): $(TEST_HASH_REQ_OBJ) $(LIB_OBJS) | $(TEST_BIN_DIR)
	$(CC) $(TEST_HASH_REQ_OBJ) $(LIB_OBJS) -o $@ $(LDFLAGS)
	@echo "✓ Built test: $@"

# Правило для тестовых объектных файлов
$(TEST_OBJ_DIR)/%.o: $(TEST_SRC_DIR)/%.c | $(TEST_OBJ_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@
	@echo "  Compiled test: $<"

# Запуск юнит-тестов
test: test_build
	@echo ""
	@echo "=== Running All Unit Tests ==="
	@echo ""
	@echo "1. CSPRNG Tests:"
	@$(TEST_CSPRNG_TARGET) && echo "   ✓ CSPRNG tests passed" || (echo "   ✗ CSPRNG tests failed" && exit 1)
	@echo ""
	@echo "2. Round-trip Tests:"
	@$(TEST_ROUNDTRIP_TARGET) && echo "   ✓ Round-trip tests passed" || (echo "   ✗ Round-trip tests failed" && exit 1)
	@echo ""
	@echo "3. Basic Hash Function Tests:"
	@$(TEST_HASH_TARGET) && echo "   ✓ Basic hash function tests passed" || (echo "   ✗ Basic hash function tests failed" && exit 1)
	@echo ""
	@echo "4. Hash Requirements Tests:"
	@$(TEST_HASH_REQ_TARGET) && echo "   ✓ Hash requirements tests passed" || (echo "   ✗ Hash requirements tests failed" && exit 1)
	@echo ""
	@echo "=== All unit tests passed! ==="

# Отдельные тесты
csprng_test: $(TEST_CSPRNG_TARGET)
	@echo "=== Running CSPRNG Tests ==="
	@$(TEST_CSPRNG_TARGET)

roundtrip_test: $(TEST_ROUNDTRIP_TARGET)
	@echo "=== Running Round-trip Tests ==="
	@$(TEST_ROUNDTRIP_TARGET)

hash_test: $(TEST_HASH_TARGET)
	@echo "=== Running Basic Hash Function Tests ==="
	@$(TEST_HASH_TARGET)

hash_req_test: $(TEST_HASH_REQ_TARGET)
	@echo "=== Running Hash Requirements Tests ==="
	@$(TEST_HASH_REQ_TARGET)

# Запуск всех тестов (юнит + интеграционные)
run_tests: test_build
	@echo ""
	@echo "=== Running Complete Test Suite ==="
	@echo ""
	
	# Юнит-тесты
	@echo "1. Unit Tests:"
	@$(TEST_CSPRNG_TARGET) > $(TEST_RESULTS_DIR)/csprng_test.log 2>&1 && \
	    echo "   ✓ CSPRNG tests passed" || (echo "   ✗ CSPRNG tests failed" && cat $(TEST_RESULTS_DIR)/csprng_test.log && false)
	@$(TEST_ROUNDTRIP_TARGET) > $(TEST_RESULTS_DIR)/roundtrip_test.log 2>&1 && \
	    echo "   ✓ Round-trip tests passed" || (echo "   ✗ Round-trip tests failed" && cat $(TEST_RESULTS_DIR)/roundtrip_test.log && false)
	@$(TEST_HASH_TARGET) > $(TEST_RESULTS_DIR)/hash_test.log 2>&1 && \
	    echo "   ✓ Basic hash function tests passed" || (echo "   ✗ Basic hash function tests failed" && cat $(TEST_RESULTS_DIR)/hash_test.log && false)
	@$(TEST_HASH_REQ_TARGET) > $(TEST_RESULTS_DIR)/hash_req_test.log 2>&1 && \
	    echo "   ✓ Hash requirements tests passed" || (echo "   ✗ Hash requirements tests failed" && cat $(TEST_RESULTS_DIR)/hash_req_test.log && false)
	
	@echo ""
	@echo "2. Integration Tests:"
	
	# Создаем тестовые файлы
	@mkdir -p $(TEST_DATA_DIR)/test_files
	@echo "Test data for integration" > $(TEST_DATA_DIR)/test_files/test1.txt
	@echo -n "0123456789ABCDEF" > $(TEST_DATA_DIR)/test_16_bytes.txt
	@echo -n "0123456789ABCDE" > $(TEST_DATA_DIR)/test_15_bytes.txt
	
	# Round-trip integration test
	@chmod +x $(TEST_SCRIPTS_DIR)/test_roundtrip.sh 2>/dev/null || true
	@if [ -f "$(TEST_SCRIPTS_DIR)/test_roundtrip.sh" ]; then \
	    echo "   Running round-trip integration test..."; \
	    $(TEST_SCRIPTS_DIR)/test_roundtrip.sh > $(TEST_RESULTS_DIR)/integration_roundtrip.log 2>&1 && \
	    echo "   ✓ Round-trip integration test passed" || (echo "   ✗ Round-trip integration test failed" && false); \
	else \
	    echo "   ⚠ Round-trip integration script not found"; \
	fi
	
	# Hash integration test
	@if [ -f "$(TARGET)" ]; then \
	    echo "   Running hash integration test..."; \
	    echo "Test hash data" > $(TEST_DATA_DIR)/hash_test.txt; \
	    $(TARGET) dgst --algorithm sha256 --input $(TEST_DATA_DIR)/hash_test.txt > $(TEST_RESULTS_DIR)/hash_integration.log 2>&1 && \
	    echo "   ✓ Hash integration test passed" || (echo "   ✗ Hash integration test failed" && false); \
	    \
	    # Test stdin input \
	    echo "   Testing stdin input..."; \
	    echo -n "abc" | $(TARGET) dgst --algorithm sha256 --input - > $(TEST_RESULTS_DIR)/hash_stdin.log 2>&1 && \
	    echo "   ✓ Stdin hash test passed" || (echo "   ✗ Stdin hash test failed" && false); \
	else \
	    echo "   ⚠ Main binary not found for hash integration test"; \
	fi
	
	# Key generation test
	@chmod +x $(TEST_SCRIPTS_DIR)/test_key_generation.sh 2>/dev/null || true
	@if [ -f "$(TEST_SCRIPTS_DIR)/test_key_generation.sh" ]; then \
	    echo "   Running key generation test..."; \
	    $(TEST_SCRIPTS_DIR)/test_key_generation.sh > $(TEST_RESULTS_DIR)/integration_keygen.log 2>&1 && \
	    echo "   ✓ Key generation test passed" || (echo "   ✗ Key generation test failed" && false); \
	else \
	    echo "   ⚠ Key generation script not found"; \
	fi
	
	@echo ""
	@echo "=== All tests completed ==="
	@echo "Logs available in $(TEST_RESULTS_DIR)/"

# Генерация данных для NIST тестов
nist_test: $(TEST_CSPRNG_TARGET) | $(TEST_RESULTS_DIR)
	@echo "=== Generating NIST Test Data ==="
	@$(TEST_CSPRNG_TARGET) 2>/dev/null || true
	@if [ -f "$(TEST_RESULTS_DIR)/nist_test_data.bin" ]; then \
	    size=$$(stat -c%s "$(TEST_RESULTS_DIR)/nist_test_data.bin"); \
	    echo "✓ Generated $(TEST_RESULTS_DIR)/nist_test_data.bin ($$size bytes)"; \
	    echo ""; \
	    echo "To run NIST STS:"; \
	    echo "1. Download NIST STS from https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"; \
	    echo "2. Compile: tar -xzf sts-2.1.2.tar.gz && cd sts-2.1.2 && make"; \
	    echo "3. Run: ./assess 1000000"; \
	    echo "4. Use $(TEST_RESULTS_DIR)/nist_test_data.bin as input"; \
	else \
	    echo "⚠ NIST test data not generated"; \
	    echo "Running test manually:"; \
	    $(TEST_CSPRNG_TARGET); \
	fi

# Установка зависимостей
install-dependencies:
	@echo "=== Installing Dependencies ==="
	sudo apt-get update
	sudo apt-get install -y build-essential libssl-dev xxd openssl
	@echo "✓ Dependencies installed"

# Создание директорий
$(OBJ_DIR):
	@mkdir -p $(OBJ_DIR)
	@mkdir -p $(OBJ_DIR)/hash
	@mkdir -p $(OBJ_DIR)/modes
	@echo "Created directory: $@"

$(BIN_DIR):
	@mkdir -p $(BIN_DIR)
	@echo "Created directory: $@"

$(TEST_BIN_DIR):
	@mkdir -p $(TEST_BIN_DIR)
	@echo "Created directory: $@"

$(TEST_OBJ_DIR):
	@mkdir -p $(TEST_OBJ_DIR)
	@echo "Created directory: $@"

$(TEST_RESULTS_DIR):
	@mkdir -p $(TEST_RESULTS_DIR)
	@echo "Created directory: $@"

# Очистка
clean:
	@echo "=== Cleaning Build Artifacts ==="
	rm -rf $(OBJ_DIR) $(BIN_DIR)
	rm -rf $(TEST_OBJ_DIR) $(TEST_BIN_DIR)
	rm -f $(TEST_RESULTS_DIR)/*.log $(TEST_RESULTS_DIR)/nist_test_data.bin 2>/dev/null || true
	rm -f $(TEST_DATA_DIR)/*.enc $(TEST_DATA_DIR)/*.dec $(TEST_DATA_DIR)/test_*.txt 2>/dev/null || true
	rm -f $(TEST_DATA_DIR)/test_files/*.enc $(TEST_DATA_DIR)/test_files/*.dec 2>/dev/null || true
	rm -f $(TEST_DATA_DIR)/hash_test.txt 2>/dev/null || true
	@echo "✓ Cleaned all build artifacts"

# Автоматическое создание директорий перед сборкой
$(OBJS): | $(OBJ_DIR)
$(TEST_OBJS): | $(TEST_OBJ_DIR)
$(TARGET): | $(BIN_DIR)
$(TEST_TARGETS): | $(TEST_BIN_DIR)```

## ИСХОДНЫЙ КОД (C/C++)
### Файл: include/cli_parser.h
```c
#ifndef CLI_PARSER_H
#define CLI_PARSER_H

#include <stdlib.h>
#include "types.h"
#include "hash.h"

typedef enum {
    MODE_ENCRYPT_DECRYPT,
    MODE_DIGEST,
    MODE_UNKNOWN
} operation_mode_t;

typedef struct {
    operation_mode_t operation_mode;  // Основной режим: шифрование или хеширование
    cipher_mode_t cipher_mode;        // Режим шифрования (только для MODE_ENCRYPT_DECRYPT)
    hash_algorithm_t hash_algorithm;  // Алгоритм хеширования (только для MODE_DIGEST)
    char* algorithm;                  // Строковый алгоритм
    unsigned char* key;
    size_t key_len;
    char* input_file;
    char* output_file;
    unsigned char* iv;
    size_t iv_len;
    int iv_provided;
    char* generated_key_hex;
    int verify_mode;                  // Для будущей HMAC-верификации
    char* verify_file;                // Файл для верификации
} cli_args_t;

int parse_arguments(int argc, char* argv[], cli_args_t* args);
void free_cli_args(cli_args_t* args);
void print_usage(const char* program_name);
cipher_mode_t parse_cipher_mode(const char* mode_str);
int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len);

#endif```

### Файл: include/common.h
```c
#ifndef COMMON_H
#define COMMON_H

#include <stdlib.h>
#include "types.h"

#define AES_BLOCK_SIZE 16

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

// AES block operations
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);
void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);

// Utility
int requires_padding(cipher_mode_t mode);
void generate_random_iv(unsigned char* iv, size_t len);

#endif```

### Файл: include/crypto.h
```c
#ifndef CRYPTO_H
#define CRYPTO_H

#include <stdlib.h>
#include "types.h"

// ECB mode
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);
unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);

// Other modes
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

#endif```

### Файл: include/csprng.h
```c
#ifndef CSPRNG_H
#define CSPRNG_H

#include <stdlib.h>

int generate_random_bytes(unsigned char *buffer, size_t num_bytes);
char* generate_random_key_hex(size_t key_len);

#endif```

### Файл: include/file_io.h
```c
#ifndef FILE_IO_H
#define FILE_IO_H

#include <stdlib.h>

unsigned char* read_file(const char* filename, size_t* file_size);
int write_file(const char* filename, const unsigned char* data, size_t data_size);

#endif```

### Файл: include/hash.h
```c
#ifndef HASH_H
#define HASH_H

#include "hash/sha256.h"
#include "hash/sha3_256.h"

typedef enum {
    HASH_SHA256,
    HASH_SHA3_256,
    HASH_UNKNOWN
} hash_algorithm_t;

hash_algorithm_t parse_hash_algorithm(const char *algorithm_str);
char* compute_hash(hash_algorithm_t algorithm, const char *filename);

#endif```

### Файл: include/hash/sha256.h
```c
#ifndef SHA256_H
#define SHA256_H

#include <stddef.h>
#include <stdint.h>

#define SHA256_BLOCK_SIZE 32
#define SHA256_BUF_SIZE 64

typedef struct {
    uint32_t state[8];
    uint64_t bit_count;
    unsigned char buffer[SHA256_BUF_SIZE];
    uint32_t buffer_len;
} SHA256_CTX;

void sha256_init(SHA256_CTX *ctx);
void sha256_update(SHA256_CTX *ctx, const unsigned char *data, size_t len);
void sha256_final(SHA256_CTX *ctx, unsigned char hash[SHA256_BLOCK_SIZE]);
void sha256(const unsigned char *data, size_t len, unsigned char hash[SHA256_BLOCK_SIZE]);
char* sha256_hex(const unsigned char *data, size_t len);
char* sha256_file(const char *filename);

#endif```

### Файл: include/hash/sha3_256.h
```c
#ifndef SHA3_256_H
#define SHA3_256_H

#include <openssl/evp.h>
#include <stddef.h>

char* sha3_256_hex(const unsigned char *data, size_t len);
char* sha3_256_file(const char *filename);

#endif```

### Файл: include/modes/ecb.h
```c
#ifndef ECB_H
#define ECB_H

#include <stdlib.h>

void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

#endif```

### Файл: include/types.h
```c
#ifndef TYPES_H
#define TYPES_H

typedef enum {
    CIPHER_MODE_ECB,
    CIPHER_MODE_CBC,
    CIPHER_MODE_CFB,
    CIPHER_MODE_OFB,
    CIPHER_MODE_CTR,
    CIPHER_MODE_UNKNOWN
} cipher_mode_t;

#endif```

### Файл: src/cli_parser.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>

#include "../include/cli_parser.h"
#include "../include/csprng.h"
#include "../include/common.h"
#include "../include/hash.h"

// Функция для парсинга аргументов шифрования/дешифрования
static int parse_crypto_arguments(int argc, char* argv[], cli_args_t* args) {
    int encrypt_flag = 0;
    int decrypt_flag = 0;
    char* mode_str = NULL;
    
    // Начинаем с i = 1, так как argv[0] это имя программы
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-algorithm") == 0 && i + 1 < argc) {
            args->algorithm = malloc(strlen(argv[i+1]) + 1);
            if (args->algorithm) strcpy(args->algorithm, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-mode") == 0 && i + 1 < argc) {
            mode_str = malloc(strlen(argv[i+1]) + 1);
            if (mode_str) strcpy(mode_str, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-encrypt") == 0) {
            encrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-decrypt") == 0) {
            decrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-key") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->key, &args->key_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            i++;
        }
        else if (strcmp(argv[i], "-iv") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->iv, &args->iv_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            args->iv_provided = 1;
            i++;
        }
        else if (strcmp(argv[i], "-input") == 0 && i + 1 < argc) {
            args->input_file = malloc(strlen(argv[i+1]) + 1);
            if (args->input_file) strcpy(args->input_file, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-output") == 0 && i + 1 < argc) {
            args->output_file = malloc(strlen(argv[i+1]) + 1);
            if (args->output_file) strcpy(args->output_file, argv[i+1]);
            i++;
        }
        else {
            fprintf(stderr, "Error: Unknown argument '%s'\n", argv[i]);
            print_usage(argv[0]);
            if (mode_str) free(mode_str);
            return 0;
        }
    }
    
    // Parse cipher mode
    if (mode_str) {
        args->cipher_mode = parse_cipher_mode(mode_str);
        free(mode_str);
    }
    
    // Set operation based on flags
    if (encrypt_flag && decrypt_flag) {
        fprintf(stderr, "Error: Cannot specify both -encrypt and -decrypt\n");
        return 0;
    }
    else if (encrypt_flag) {
        // Устанавливаем режим шифрования
        // (operation_mode уже установлен в MODE_ENCRYPT_DECRYPT)
    }
    else if (decrypt_flag) {
        // Устанавливаем режим дешифрования
        // (operation_mode уже установлен в MODE_ENCRYPT_DECRYPT)
    }
    else {
        fprintf(stderr, "Error: Must specify either -encrypt or -decrypt for crypto mode\n");
        return 0;
    }
    
    // Validation
    if (args->algorithm == NULL || strcmp(args->algorithm, "aes") != 0) {
        fprintf(stderr, "Error: Algorithm must be 'aes' for crypto mode\n");
        return 0;
    }
    
    if (args->cipher_mode == CIPHER_MODE_UNKNOWN) {
        fprintf(stderr, "Error: Mode must be one of: ecb, cbc, cfb, ofb, ctr\n");
        return 0;
    }
    
    // KEY VALIDATION - UPDATED FOR MILESTONE 3
    if (encrypt_flag && args->key == NULL) {
        // Генерируем случайный ключ
        char* generated_key_hex = generate_random_key_hex(16);
        if (generated_key_hex == NULL) {
            fprintf(stderr, "Error: Failed to generate random key\n");
            return 0;
        }
        
        // Парсим сгенерированный ключ как обычный hex
        if (!hex_to_bytes(generated_key_hex, &args->key, &args->key_len)) {
            free(generated_key_hex);
            return 0;
        }
        
        // Сохраняем hex представление для вывода пользователю
        args->generated_key_hex = generated_key_hex;
    } else if (decrypt_flag && args->key == NULL) {
        // Для дешифрования ключ обязателен
        fprintf(stderr, "Error: Key is required for decryption\n");
        return 0;
    } else if (args->key != NULL && args->key_len != 16) {
        fprintf(stderr, "Error: Key must be 16 bytes for AES-128\n");
        return 0;
    }
    
    // Проверка на слабые ключи (дополнительное требование)
    if (args->key != NULL && encrypt_flag && args->generated_key_hex == NULL) {
        int is_weak = 1;
        // Проверяем, не все ли байты одинаковые
        for (size_t i = 1; i < args->key_len; i++) {
            if (args->key[i] != args->key[0]) {
                is_weak = 0;
                break;
            }
        }
        
        if (is_weak) {
            fprintf(stderr, "Warning: The provided key may be weak (all bytes identical)\n");
        }
        
        // Проверяем последовательные байты
        is_weak = 1;
        for (size_t i = 1; i < args->key_len; i++) {
            if (args->key[i] != args->key[i-1] + 1) {
                is_weak = 0;
                break;
            }
        }
        
        if (is_weak) {
            fprintf(stderr, "Warning: The provided key may be weak (sequential bytes)\n");
        }
    }
    
    if (args->input_file == NULL) {
        fprintf(stderr, "Error: Input file is required\n");
        return 0;
    }
    
    // IV validation
    if (encrypt_flag && args->iv_provided) {
        fprintf(stderr, "Warning: IV provided during encryption will be ignored (using random IV)\n");
        free(args->iv);
        args->iv = NULL;
        args->iv_provided = 0;
    }
    
    if (decrypt_flag && args->cipher_mode != CIPHER_MODE_ECB && !args->iv_provided) {
        fprintf(stderr, "Warning: No IV provided for decryption, will read from file\n");
    }
    
    if (args->iv_provided && args->iv_len != 16) {
        fprintf(stderr, "Error: IV must be 16 bytes\n");
        return 0;
    }
    
    if (args->output_file == NULL) {
        // Generate default output filename
        const char* extension = (encrypt_flag) ? ".enc" : ".dec";
        size_t len = strlen(args->input_file) + strlen(extension) + 1;
        args->output_file = malloc(len);
        if (args->output_file) {
            snprintf(args->output_file, len, "%s%s", args->input_file, extension);
        }
    }
    
    return 1;
}

// Функция для парсинга аргументов хеширования
static int parse_digest_arguments(int argc, char* argv[], cli_args_t* args) {
    int i = 2; // Пропускаем "cryptocore" и "dgst"
    
    for (; i < argc; i++) {
        if (strcmp(argv[i], "--algorithm") == 0 && i + 1 < argc) {
            args->hash_algorithm = parse_hash_algorithm(argv[i + 1]);
            if (args->hash_algorithm == HASH_UNKNOWN) {
                fprintf(stderr, "Error: Unknown hash algorithm '%s'. Supported: sha256, sha3-256\n", argv[i + 1]);
                return 0;
            }
            i++;
        }
        else if (strcmp(argv[i], "--input") == 0 && i + 1 < argc) {
            args->input_file = malloc(strlen(argv[i + 1]) + 1);
            if (args->input_file) strcpy(args->input_file, argv[i + 1]);
            i++;
        }
        else if (strcmp(argv[i], "--output") == 0 && i + 1 < argc) {
            args->output_file = malloc(strlen(argv[i + 1]) + 1);
            if (args->output_file) strcpy(args->output_file, argv[i + 1]);
            i++;
        }
        else {
            fprintf(stderr, "Error: Unknown argument '%s' for dgst command\n", argv[i]);
            return 0;
        }
    }
    
    // Валидация
    if (args->hash_algorithm == HASH_UNKNOWN) {
        fprintf(stderr, "Error: Hash algorithm is required (--algorithm sha256|sha3-256)\n");
        return 0;
    }
    
    if (args->input_file == NULL) {
        fprintf(stderr, "Error: Input file is required (--input FILE)\n");
        return 0;
    }
    
    return 1;
}

void print_usage(const char* program_name) {
    fprintf(stderr, "Usage:\n");
    fprintf(stderr, "  Encryption/Decryption:\n");
    fprintf(stderr, "    %s -algorithm aes -mode [ecb|cbc|cfb|ofb|ctr] (-encrypt | -decrypt) [-key HEX_KEY] -input INPUT_FILE [-output OUTPUT_FILE] [-iv HEX_IV]\n", program_name);
    fprintf(stderr, "\n");
    fprintf(stderr, "  Hashing:\n");
    fprintf(stderr, "    %s dgst --algorithm [sha256|sha3-256] --input INPUT_FILE [--output OUTPUT_FILE]\n", program_name);
    fprintf(stderr, "\n");
    fprintf(stderr, "Examples:\n");
    fprintf(stderr, "  Encryption with generated key: %s -algorithm aes -mode cbc -encrypt -input plain.txt -output cipher.bin\n", program_name);
    fprintf(stderr, "  Hashing: %s dgst --algorithm sha256 --input document.pdf\n", program_name);
}

cipher_mode_t parse_cipher_mode(const char* mode_str) {
    if (strcmp(mode_str, "ecb") == 0) return CIPHER_MODE_ECB;
    if (strcmp(mode_str, "cbc") == 0) return CIPHER_MODE_CBC;
    if (strcmp(mode_str, "cfb") == 0) return CIPHER_MODE_CFB;
    if (strcmp(mode_str, "ofb") == 0) return CIPHER_MODE_OFB;
    if (strcmp(mode_str, "ctr") == 0) return CIPHER_MODE_CTR;
    return CIPHER_MODE_UNKNOWN;
}

int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len) {
    // Убрана проверка на @ - теперь ключи и IV принимаются без префикса
    size_t hex_len = strlen(hex_str);
    
    if (hex_len == 0 || hex_len % 2 != 0) {
        fprintf(stderr, "Error: Hexadecimal value must have even number of digits\n");
        return 0;
    }
    
    *len = hex_len / 2;
    *bytes = malloc(*len);
    if (*bytes == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        return 0;
    }
    
    for (size_t i = 0; i < *len; i++) {
        if (sscanf(hex_str + 2*i, "%2hhx", &(*bytes)[i]) != 1) {
            fprintf(stderr, "Error: Invalid hexadecimal character at position %zu\n", 2*i);
            free(*bytes);
            *bytes = NULL;
            return 0;
        }
    }
    
    return 1;
}

int parse_arguments(int argc, char* argv[], cli_args_t* args) {
    memset(args, 0, sizeof(cli_args_t));
    args->operation_mode = MODE_UNKNOWN;
    args->cipher_mode = CIPHER_MODE_UNKNOWN;
    args->hash_algorithm = HASH_UNKNOWN;
    
    // Проверяем, есть ли подкоманда dgst
    if (argc > 1 && strcmp(argv[1], "dgst") == 0) {
        args->operation_mode = MODE_DIGEST;
        return parse_digest_arguments(argc, argv, args);
    } else {
        args->operation_mode = MODE_ENCRYPT_DECRYPT;
        return parse_crypto_arguments(argc, argv, args);
    }
}

void free_cli_args(cli_args_t* args) {
    if (args->algorithm) free(args->algorithm);
    if (args->key) free(args->key);
    if (args->input_file) free(args->input_file);
    if (args->output_file) free(args->output_file);
    if (args->iv) free(args->iv);
    if (args->generated_key_hex) free(args->generated_key_hex);
    if (args->verify_file) free(args->verify_file);
}```

### Файл: src/crypto.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>

#include "../include/crypto.h"
#include "../include/common.h"



// Keep existing ECB functions but update them to use new helper functions
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        aes_encrypt_block(padded_data + i, output + i, key);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for ECB decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        aes_decrypt_block(input + i, output + i, key);
    }
    
    if (!pkcs7_unpad(&output, &input_len)) {
        fprintf(stderr, "Error: PKCS#7 unpadding failed in ECB mode\n");
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}```

### Файл: src/csprng.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>

#include "../include/csprng.h"



int generate_random_bytes(unsigned char *buffer, size_t num_bytes) {
    if (buffer == NULL || num_bytes == 0) {
        fprintf(stderr, "Error: Invalid parameters for random generation\n");
        return -1;
    }
    
    if (RAND_bytes(buffer, num_bytes) != 1) {
        fprintf(stderr, "Error: Cryptographically secure random generation failed\n");
        return -1;
    }
    
    return 0;
}

char* generate_random_key_hex(size_t key_len) {
    unsigned char* key_bytes = malloc(key_len);
    if (key_bytes == NULL) {
        fprintf(stderr, "Error: Memory allocation failed for key generation\n");
        return NULL;
    }
    
    if (generate_random_bytes(key_bytes, key_len) != 0) {
        free(key_bytes);
        return NULL;
    }
    
    // Convert to hexadecimal string (БЕЗ @ в начале!)
    char* hex_string = malloc(key_len * 2 + 1); // +1 for null terminator
    if (hex_string == NULL) {
        free(key_bytes);
        return NULL;
    }
    
    for (size_t i = 0; i < key_len; i++) {
        sprintf(hex_string + i * 2, "%02x", key_bytes[i]);
    }
    
    free(key_bytes);
    return hex_string;
}```

### Файл: src/file_io.c
```c
#include <stdio.h>
#include <stdlib.h>

#include "../include/file_io.h"



unsigned char* read_file(const char* filename, size_t* file_size) {
    FILE* file = fopen(filename, "rb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", filename);
        return NULL;
    }
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    if (size <= 0) {
        fprintf(stderr, "Error: Input file is empty or invalid\n");
        fclose(file);
        return NULL;
    }
    
    unsigned char* buffer = malloc(size);
    if (buffer == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        fclose(file);
        return NULL;
    }
    
    size_t bytes_read = fread(buffer, 1, size, file);
    fclose(file);
    
    if (bytes_read != (size_t)size) {
        fprintf(stderr, "Error: Failed to read entire file\n");
        free(buffer);
        return NULL;
    }
    
    *file_size = bytes_read;
    return buffer;
}

int write_file(const char* filename, const unsigned char* data, size_t data_size) {
    FILE* file = fopen(filename, "wb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", filename);
        return 0;
    }
    
    size_t bytes_written = fwrite(data, 1, data_size, file);
    fclose(file);
    
    if (bytes_written != data_size) {
        fprintf(stderr, "Error: Failed to write entire file\n");
        return 0;
    }
    
    return 1;
}```

### Файл: src/hash.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>

#include "../include/hash.h"
#include "../include/hash/sha256.h"
#include "../include/hash/sha3_256.h"

hash_algorithm_t parse_hash_algorithm(const char *algorithm_str) {
    if (strcmp(algorithm_str, "sha256") == 0) return HASH_SHA256;
    if (strcmp(algorithm_str, "sha3-256") == 0) return HASH_SHA3_256;
    if (strcmp(algorithm_str, "sha3_256") == 0) return HASH_SHA3_256;
    return HASH_UNKNOWN;
}

char* compute_hash(hash_algorithm_t algorithm, const char *filename) {
    switch (algorithm) {
        case HASH_SHA256:
            return sha256_file(filename);
        case HASH_SHA3_256:
            return sha3_256_file(filename);
        default:
            return NULL;
    }
}

// Новая функция для вычисления хеша из stdin
char* compute_hash_from_stdin(hash_algorithm_t algorithm) {
    if (algorithm == HASH_SHA256) {
        SHA256_CTX ctx;
        sha256_init(&ctx);
        
        unsigned char buffer[4096];
        size_t bytes_read;
        
        while ((bytes_read = fread(buffer, 1, sizeof(buffer), stdin)) > 0) {
            sha256_update(&ctx, buffer, bytes_read);
        }
        
        unsigned char hash[SHA256_BLOCK_SIZE];
        sha256_final(&ctx, hash);
        
        char *hex_str = malloc(SHA256_BLOCK_SIZE * 2 + 1);
        if (!hex_str) return NULL;
        
        for (int i = 0; i < SHA256_BLOCK_SIZE; i++) {
            sprintf(hex_str + i * 2, "%02x", hash[i]);
        }
        
        hex_str[SHA256_BLOCK_SIZE * 2] = '\0';
        return hex_str;
        
    } else if (algorithm == HASH_SHA3_256) {
        EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
        const EVP_MD *md = EVP_sha3_256();
        unsigned char hash[32];
        unsigned int hash_len;
        char *hex_str = malloc(65);
        
        if (!mdctx || !hex_str) {
            if (mdctx) EVP_MD_CTX_free(mdctx);
            return NULL;
        }
        
        EVP_DigestInit_ex(mdctx, md, NULL);
        
        unsigned char buffer[4096];
        size_t bytes_read;
        
        while ((bytes_read = fread(buffer, 1, sizeof(buffer), stdin)) > 0) {
            EVP_DigestUpdate(mdctx, buffer, bytes_read);
        }
        
        EVP_DigestFinal_ex(mdctx, hash, &hash_len);
        EVP_MD_CTX_free(mdctx);
        
        for (int i = 0; i < 32; i++) {
            sprintf(hex_str + i * 2, "%02x", hash[i]);
        }
        
        hex_str[64] = '\0';
        return hex_str;
    }
    
    return NULL;
}

// Функция для вычисления хеша из данных в памяти
char* compute_hash_from_data(hash_algorithm_t algorithm, const unsigned char *data, size_t len) {
    if (algorithm == HASH_SHA256) {
        return sha256_hex(data, len);
    } else if (algorithm == HASH_SHA3_256) {
        return sha3_256_hex(data, len);
    }
    return NULL;
}```

### Файл: src/hash/sha256.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "../../include/hash/sha256.h"

// SHA-256 константы (первые 32 бита дробных частей квадратных корней первых 8 простых чисел)
static const uint32_t K[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

// Правое вращение
#define ROTRIGHT(word, bits) (((word) >> (bits)) | ((word) << (32 - (bits))))

// Мажоритарная функция
#define CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

// Σ функции
#define EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
#define EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
#define SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))

// Инициализация контекста SHA-256
void sha256_init(SHA256_CTX *ctx) {
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
    ctx->bit_count = 0;
    ctx->buffer_len = 0;
    memset(ctx->buffer, 0, SHA256_BUF_SIZE);
}

// Преобразование big-endian
static uint32_t bswap_32(uint32_t x) {
    return ((x & 0xFF000000) >> 24) |
           ((x & 0x00FF0000) >> 8) |
           ((x & 0x0000FF00) << 8) |
           ((x & 0x000000FF) << 24);
}

// Обработка одного блока (512 бит = 64 байта)
static void sha256_transform(SHA256_CTX *ctx, const unsigned char data[SHA256_BUF_SIZE]) {
    uint32_t a, b, c, d, e, f, g, h, i, j;
    uint32_t w[64];
    uint32_t temp1, temp2;
    
    // Подготовка массива w
    for (i = 0, j = 0; i < 16; ++i, j += 4) {
        w[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | data[j + 3];
    }
    
    for (i = 16; i < 64; ++i) {
        w[i] = SIG1(w[i - 2]) + w[i - 7] + SIG0(w[i - 15]) + w[i - 16];
    }
    
    // Инициализация рабочих переменных
    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];
    f = ctx->state[5];
    g = ctx->state[6];
    h = ctx->state[7];
    
    // Основной цикл
    for (i = 0; i < 64; ++i) {
        temp1 = h + EP1(e) + CH(e, f, g) + K[i] + w[i];
        temp2 = EP0(a) + MAJ(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + temp1;
        d = c;
        c = b;
        b = a;
        a = temp1 + temp2;
    }
    
    // Обновление состояния
    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
    ctx->state[5] += f;
    ctx->state[6] += g;
    ctx->state[7] += h;
}

// Добавление данных в хеш
void sha256_update(SHA256_CTX *ctx, const unsigned char *data, size_t len) {
    uint32_t i;
    
    for (i = 0; i < len; ++i) {
        ctx->buffer[ctx->buffer_len] = data[i];
        ctx->buffer_len++;
        
        if (ctx->buffer_len == SHA256_BUF_SIZE) {
            sha256_transform(ctx, ctx->buffer);
            ctx->bit_count += 512;
            ctx->buffer_len = 0;
        }
    }
}

// Завершение хеширования
void sha256_final(SHA256_CTX *ctx, unsigned char hash[SHA256_BLOCK_SIZE]) {
    uint32_t i;
    unsigned char bit_count_bits[8];
    
    // Преобразование bit_count в биты (big-endian)
    uint64_t bit_count = ctx->bit_count + (ctx->buffer_len * 8);
    for (i = 0; i < 8; ++i) {
        bit_count_bits[i] = (unsigned char)((bit_count >> (56 - i * 8)) & 0xFF);
    }
    
    // Добавление 1 бита
    unsigned char padding = 0x80;
    sha256_update(ctx, &padding, 1);
    
    // Добавление нулей до длины 448 бит (56 байт)
    padding = 0x00;
    while (ctx->buffer_len != 56) {
        sha256_update(ctx, &padding, 1);
    }
    
    // Добавление длины сообщения (64 бита)
    sha256_update(ctx, bit_count_bits, 8);
    
    // Преобразование состояния в байты (big-endian)
    for (i = 0; i < 8; ++i) {
        hash[i * 4] = (ctx->state[i] >> 24) & 0xFF;
        hash[i * 4 + 1] = (ctx->state[i] >> 16) & 0xFF;
        hash[i * 4 + 2] = (ctx->state[i] >> 8) & 0xFF;
        hash[i * 4 + 3] = ctx->state[i] & 0xFF;
    }
}

// Удобная функция для хеширования данных
void sha256(const unsigned char *data, size_t len, unsigned char hash[SHA256_BLOCK_SIZE]) {
    SHA256_CTX ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, data, len);
    sha256_final(&ctx, hash);
}

// Преобразование хеша в hex-строку
char* sha256_hex(const unsigned char *data, size_t len) {
    unsigned char hash[SHA256_BLOCK_SIZE];
    char *hex_str = malloc(SHA256_BLOCK_SIZE * 2 + 1);
    
    if (!hex_str) return NULL;
    
    sha256(data, len, hash);
    
    for (int i = 0; i < SHA256_BLOCK_SIZE; i++) {
        sprintf(hex_str + i * 2, "%02x", hash[i]);
    }
    
    hex_str[SHA256_BLOCK_SIZE * 2] = '\0';
    return hex_str;
}

// Хеширование файла
char* sha256_file(const char *filename) {
    FILE *file = fopen(filename, "rb");
    if (!file) return NULL;
    
    SHA256_CTX ctx;
    sha256_init(&ctx);
    
    unsigned char buffer[4096];
    size_t bytes_read;
    
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        sha256_update(&ctx, buffer, bytes_read);
    }
    
    fclose(file);
    
    unsigned char hash[SHA256_BLOCK_SIZE];
    sha256_final(&ctx, hash);
    
    char *hex_str = malloc(SHA256_BLOCK_SIZE * 2 + 1);
    if (!hex_str) return NULL;
    
    for (int i = 0; i < SHA256_BLOCK_SIZE; i++) {
        sprintf(hex_str + i * 2, "%02x", hash[i]);
    }
    
    hex_str[SHA256_BLOCK_SIZE * 2] = '\0';
    return hex_str;
}```

### Файл: src/hash/sha3_256.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>

#include "../../include/hash/sha3_256.h"

char* sha3_256_hex(const unsigned char *data, size_t len) {
    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    const EVP_MD *md = EVP_sha3_256();
    unsigned char hash[32];
    unsigned int hash_len;
    char *hex_str = malloc(65);
    
    if (!mdctx || !hex_str) {
        if (mdctx) EVP_MD_CTX_free(mdctx);
        return NULL;
    }
    
    EVP_DigestInit_ex(mdctx, md, NULL);
    EVP_DigestUpdate(mdctx, data, len);
    EVP_DigestFinal_ex(mdctx, hash, &hash_len);
    EVP_MD_CTX_free(mdctx);
    
    for (int i = 0; i < 32; i++) {
        sprintf(hex_str + i * 2, "%02x", hash[i]);
    }
    
    hex_str[64] = '\0';
    return hex_str;
}

char* sha3_256_file(const char *filename) {
    FILE *file = fopen(filename, "rb");
    if (!file) return NULL;
    
    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
    const EVP_MD *md = EVP_sha3_256();
    unsigned char hash[32];
    unsigned int hash_len;
    char *hex_str = malloc(65);
    
    if (!mdctx || !hex_str) {
        fclose(file);
        if (mdctx) EVP_MD_CTX_free(mdctx);
        return NULL;
    }
    
    EVP_DigestInit_ex(mdctx, md, NULL);
    
    unsigned char buffer[4096];
    size_t bytes_read;
    
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        EVP_DigestUpdate(mdctx, buffer, bytes_read);
    }
    
    fclose(file);
    EVP_DigestFinal_ex(mdctx, hash, &hash_len);
    EVP_MD_CTX_free(mdctx);
    
    for (int i = 0; i < 32; i++) {
        sprintf(hex_str + i * 2, "%02x", hash[i]);
    }
    
    hex_str[64] = '\0';
    return hex_str;
}```

### Файл: src/main.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>

#include "../include/cli_parser.h"
#include "../include/file_io.h"
#include "../include/crypto.h"
#include "../include/common.h"
#include "../include/hash.h"
#include "../include/csprng.h"

// Вспомогательная функция для обработки шифрования/дешифрования
static int handle_crypto_operation(cli_args_t* args, int is_encrypt) {
    // Выводим сгенерированный ключ если он был создан
    if (args->generated_key_hex != NULL) {
        printf("Generated random key: %s\n", args->generated_key_hex);
    }
    
    // Read input file
    size_t input_size;
    unsigned char* input_data = read_file(args->input_file, &input_size);
    if (input_data == NULL) {
        return 0;
    }
    
    // Handle IV based on operation and mode
    unsigned char iv[16];
    const unsigned char* iv_ptr = NULL;
    size_t data_start = 0;
    size_t data_size = input_size;
    
    if (is_encrypt) {
        // Generate random IV for modes that need it
        if (args->cipher_mode != CIPHER_MODE_ECB) {
            if (generate_random_bytes(iv, 16) == 0) {
                iv_ptr = iv;
            } else {
                fprintf(stderr, "Error: Failed to generate IV\n");
                free(input_data);
                return 0;
            }
        }
    } else { // DECRYPT
        if (args->cipher_mode != CIPHER_MODE_ECB) {
            if (args->iv_provided) {
                // Use provided IV
                iv_ptr = args->iv;
            } else {
                // Read IV from file (first 16 bytes)
                if (input_size < 16) {
                    fprintf(stderr, "Error: Input file too short to contain IV\n");
                    free(input_data);
                    return 0;
                }
                iv_ptr = input_data;
                data_start = 16;
                data_size = input_size - 16;
            }
        }
    }
    
    // Process data
    size_t output_size;
    unsigned char* output_data = NULL;
    unsigned char* final_output = NULL;
    size_t final_size = 0;
    
    switch (args->cipher_mode) {
        case CIPHER_MODE_ECB:
            if (is_encrypt) {
                output_data = aes_ecb_encrypt(input_data + data_start, data_size, args->key, &output_size);
            } else {
                output_data = aes_ecb_decrypt(input_data + data_start, data_size, args->key, &output_size);
            }
            break;
        case CIPHER_MODE_CBC:
            if (is_encrypt) {
                output_data = aes_cbc_encrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            } else {
                output_data = aes_cbc_decrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CFB:
            if (is_encrypt) {
                output_data = aes_cfb_encrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            } else {
                output_data = aes_cfb_decrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_OFB:
            if (is_encrypt) {
                output_data = aes_ofb_encrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            } else {
                output_data = aes_ofb_decrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CTR:
            if (is_encrypt) {
                output_data = aes_ctr_encrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            } else {
                output_data = aes_ctr_decrypt(input_data + data_start, data_size, args->key, iv_ptr, &output_size);
            }
            break;
        default:
            fprintf(stderr, "Error: Unsupported mode\n");
            free(input_data);
            return 0;
    }
    
    free(input_data);
    
    if (output_data == NULL) {
        fprintf(stderr, "Error: Cryptographic operation failed\n");
        return 0;
    }
    
    // Prepare final output (with IV for encryption)
    if (is_encrypt && args->cipher_mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        final_size = 16 + output_size;
        final_output = malloc(final_size);
        if (final_output) {
            memcpy(final_output, iv_ptr, 16);
            memcpy(final_output + 16, output_data, output_size);
        }
        free(output_data);
    } else {
        final_output = output_data;
        final_size = output_size;
    }
    
    if (final_output == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        return 0;
    }
    
    // Write output file
    if (!write_file(args->output_file, final_output, final_size)) {
        free(final_output);
        return 0;
    }
    
    printf("Success: %s -> %s\n", args->input_file, args->output_file);
    
    // Print IV info for encryption
    if (is_encrypt && args->cipher_mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        printf("Generated IV: ");
        for (int i = 0; i < 16; i++) {
            printf("%02x", iv_ptr[i]);
        }
        printf("\n");
    }
    
    free(final_output);
    return 1;
}

int main(int argc, char* argv[]) {
    cli_args_t args;
    
    if (!parse_arguments(argc, argv, &args)) {
        print_usage(argv[0]);
        free_cli_args(&args);
        return 1;
    }
    
    // Обработка режима хеширования
    if (args.operation_mode == MODE_DIGEST) {
        char* hash = NULL;
        const char* input_name = args.input_file;
        
        // Проверяем, является ли ввод stdin ("-")
        if (strcmp(args.input_file, "-") == 0) {
            hash = compute_hash_from_stdin(args.hash_algorithm);
            input_name = "-"; // Специальное имя для stdin
        } else {
            hash = compute_hash(args.hash_algorithm, args.input_file);
        }
        
        if (!hash) {
            fprintf(stderr, "Error: Failed to compute hash\n");
            free_cli_args(&args);
            return 1;
        }
        
        // Вывод результата в формате "HASH_VALUE  INPUT_FILE_PATH"
        if (args.output_file) {
            FILE* out = fopen(args.output_file, "w");
            if (!out) {
                fprintf(stderr, "Error: Cannot open output file '%s'\n", args.output_file);
                free(hash);
                free_cli_args(&args);
                return 1;
            }
            fprintf(out, "%s  %s\n", hash, input_name);
            fclose(out);
            printf("Hash written to: %s\n", args.output_file);
        } else {
            printf("%s  %s\n", hash, input_name);
        }
        
        free(hash);
        free_cli_args(&args);
        return 0;
    }
    
    // Обработка режима шифрования/дешифрования
    // Определяем, это шифрование или дешифрование
    // Проверяем аргументы командной строки
    int is_encrypt = 0;
    for (int i = 0; i < argc; i++) {
        if (strcmp(argv[i], "-encrypt") == 0) {
            is_encrypt = 1;
            break;
        } else if (strcmp(argv[i], "-decrypt") == 0) {
            is_encrypt = 0;
            break;
        }
    }
    
    if (!handle_crypto_operation(&args, is_encrypt)) {
        free_cli_args(&args);
        return 1;
    }
    
    free_cli_args(&args);
    return 0;
}```

### Файл: src/modes.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>

#include "../include/crypto.h"
#include "../include/common.h"
#include "../include/csprng.h"



// Utility functions
int requires_padding(cipher_mode_t mode) {
    return (mode == CIPHER_MODE_ECB || mode == CIPHER_MODE_CBC);
}

void generate_random_iv(unsigned char* iv, size_t len) {
    if (generate_random_bytes(iv, len) != 0) {
        fprintf(stderr, "Error: Failed to generate cryptographically secure IV\n");
        exit(1);
    }
}

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t padding_len = AES_BLOCK_SIZE - (*data_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = *data_len + padding_len;
    unsigned char* new_data = realloc(*data, new_len);
    if (new_data == NULL) return;
    
    for (size_t i = *data_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte\n");
        return 0;
    }
    
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Padding validation failed\n");
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}

// AES block encryption/decryption helper
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_EncryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_DecryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

// CBC Mode
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            block[j] = padded_data[i + j] ^ prev_block[j];
        }
        
        // Encrypt the block
        aes_encrypt_block(block, output + i, key);
        memcpy(prev_block, output + i, AES_BLOCK_SIZE);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for CBC decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Decrypt the block
        aes_decrypt_block(input + i, block, key);
        
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            output[i + j] = block[j] ^ prev_block[j];
        }
        
        memcpy(prev_block, input + i, AES_BLOCK_SIZE);
    }
    
    // Remove padding
    if (!pkcs7_unpad(&output, &input_len)) {
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}

// CFB Mode - CFB-128 implementation (fixed)
unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with encrypted block to get ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (for CFB-128)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, output + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, output + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR ciphertext with encrypted block to get plaintext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (not plaintext)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, input + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, input + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

// OFB Mode
unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting feedback register
        aes_encrypt_block(feedback, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Update feedback register with keystream (not ciphertext)
        memcpy(feedback, keystream, AES_BLOCK_SIZE);
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // OFB decryption is identical to encryption
    return aes_ofb_encrypt(input, input_len, key, iv, output_len);
}

// CTR Mode
unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char counter[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(counter, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting counter
        aes_encrypt_block(counter, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Increment counter (big-endian)
        for (int j = AES_BLOCK_SIZE - 1; j >= 0; j--) {
            if (++counter[j] != 0) break;
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // CTR decryption is identical to encryption
    return aes_ctr_encrypt(input, input_len, key, iv, output_len);
}```

### Файл: src/modes/ecb.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../../include/modes/ecb.h"

#define AES_BLOCK_SIZE 16

void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t original_len = *data_len;
    size_t padding_len = AES_BLOCK_SIZE - (original_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = original_len + padding_len;
    unsigned char* new_data = malloc(new_len);
    if (new_data == NULL) {
        fprintf(stderr, "Error: Memory allocation failed for padding\n");
        return;
    }
    
    // Copy original data
    if (original_len > 0 && *data != NULL) {
        memcpy(new_data, *data, original_len);
    }
    
    // Add padding
    for (size_t i = original_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    // Free old data and update pointers
    if (*data != NULL) {
        free(*data);
    }
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte: %d\n", padding_byte);
        return 0;
    }
    
    // Check if padding length is valid
    if (padding_byte > *data_len) {
        fprintf(stderr, "Error: Padding length exceeds data length\n");
        return 0;
    }
    
    // Verify all padding bytes
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Invalid padding bytes at position %zu\n", i);
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}```

## ТЕСТЫ
### Тестовый файл: tests/src/test_csprng.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "../../include/csprng.h"

void test_key_uniqueness() {
    printf("Testing key uniqueness...\n");
    
    const int NUM_KEYS = 1000;
    char* keys[NUM_KEYS];
    
    // Generate 1000 keys
    for (int i = 0; i < NUM_KEYS; i++) {
        keys[i] = generate_random_key_hex(16);
        assert(keys[i] != NULL);
        
        // Check for duplicates
        for (int j = 0; j < i; j++) {
            if (strcmp(keys[i], keys[j]) == 0) {
                printf("ERROR: Duplicate key found at indices %d and %d: %s\n", i, j, keys[i]);
                exit(1);
            }
        }
    }
    
    printf("✓ Successfully generated %d unique keys\n", NUM_KEYS);
    
    // Cleanup
    for (int i = 0; i < NUM_KEYS; i++) {
        free(keys[i]);
    }
}

void test_basic_distribution() {
    printf("Testing basic distribution...\n");
    
    const int NUM_SAMPLES = 10000;
    const int KEY_LEN = 16;
    unsigned char buffer[KEY_LEN];
    
    int total_bits = NUM_SAMPLES * KEY_LEN * 8;
    int ones_count = 0;
    
    for (int i = 0; i < NUM_SAMPLES; i++) {
        assert(generate_random_bytes(buffer, KEY_LEN) == 0);
        
        for (int j = 0; j < KEY_LEN; j++) {
            unsigned char byte = buffer[j];
            ones_count += (byte & 0x01) + ((byte >> 1) & 0x01) + ((byte >> 2) & 0x01) + 
                         ((byte >> 3) & 0x01) + ((byte >> 4) & 0x01) + ((byte >> 5) & 0x01) + 
                         ((byte >> 6) & 0x01) + ((byte >> 7) & 0x01);
        }
    }
    
    double ratio = (double)ones_count / total_bits;
    printf("Bit ratio (1s/total): %.4f (should be close to 0.5)\n", ratio);
    
    // Check if ratio is reasonably close to 50%
    assert(ratio > 0.49 && ratio < 0.51);
    printf("✓ Basic distribution test passed\n");
}

void test_nist_preparation() {
    printf("Preparing data for NIST tests...\n");
    
    const size_t TOTAL_SIZE = 10000000; // 10 MB
    const size_t CHUNK_SIZE = 4096;
    unsigned char buffer[CHUNK_SIZE];
    
    FILE* f = fopen("tests/results/nist_test_data.bin", "wb");
    assert(f != NULL);
    
    size_t bytes_written = 0;
    while (bytes_written < TOTAL_SIZE) {
        size_t chunk = (TOTAL_SIZE - bytes_written < CHUNK_SIZE) ? 
                      TOTAL_SIZE - bytes_written : CHUNK_SIZE;
        
        assert(generate_random_bytes(buffer, chunk) == 0);
        size_t written = fwrite(buffer, 1, chunk, f);
        assert(written == chunk);
        
        bytes_written += written;
    }
    
    fclose(f);
    printf("✓ Generated %zu bytes for NIST testing in '../results/nist_test_data.bin'\n", bytes_written);
}

int main() {
    printf("=== CSPRNG Comprehensive Tests ===\n\n");
    
    test_key_uniqueness();
    printf("\n");
    
    test_basic_distribution();
    printf("\n");
    
    test_nist_preparation();
    printf("\n");
    
    printf("=== All CSPRNG tests passed! ===\n");
    return 0;
}```

### Тестовый файл: tests/src/test_hash.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "../../include/hash.h"

void test_sha256_empty() {
    printf("Testing SHA-256 empty string... ");
    char* hash = sha256_hex((unsigned char*)"", 0);
    assert(hash != NULL);
    assert(strcmp(hash, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855") == 0);
    free(hash);
    printf("✓\n");
}

void test_sha256_abc() {
    printf("Testing SHA-256 'abc'... ");
    char* hash = sha256_hex((unsigned char*)"abc", 3);
    assert(hash != NULL);
    assert(strcmp(hash, "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad") == 0);
    free(hash);
    printf("✓\n");
}

void test_sha3_256_empty() {
    printf("Testing SHA3-256 empty string... ");
    char* hash = sha3_256_hex((unsigned char*)"", 0);
    assert(hash != NULL);
    assert(strcmp(hash, "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a") == 0);
    free(hash);
    printf("✓\n");
}

void test_file_hashing() {
    printf("Testing file hashing... ");
    
    // Создаем тестовый файл
    FILE* f = fopen("test_hash_file.txt", "w");
    assert(f != NULL);
    fprintf(f, "Hello, CryptoCore Hash!\n");
    fclose(f);
    
    // Тестируем SHA-256
    char* sha256_hash = sha256_file("test_hash_file.txt");
    assert(sha256_hash != NULL);
    
    // Тестируем SHA3-256
    char* sha3_hash = sha3_256_file("test_hash_file.txt");
    assert(sha3_hash != NULL);
    
    // Хеши должны быть разными
    assert(strcmp(sha256_hash, sha3_hash) != 0);
    
    free(sha256_hash);
    free(sha3_hash);
    remove("test_hash_file.txt");
    
    printf("✓\n");
}

int main() {
    printf("=== Hash Function Tests ===\n\n");
    
    test_sha256_empty();
    test_sha256_abc();
    test_sha3_256_empty();
    test_file_hashing();
    
    printf("\n=== All hash tests passed! ===\n");
    return 0;
}```

### Тестовый файл: tests/src/test_hash_requirements.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <sys/stat.h>

#include "../../include/hash.h"

// TEST-2: Empty Input Test
void test_empty_input() {
    printf("Testing empty input...\n");
    
    // SHA-256 empty string
    char* sha256_empty = sha256_hex((unsigned char*)"", 0);
    assert(sha256_empty != NULL);
    printf("  SHA-256 empty: %s\n", sha256_empty);
    assert(strcmp(sha256_empty, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855") == 0);
    free(sha256_empty);
    
    // SHA3-256 empty string
    char* sha3_empty = sha3_256_hex((unsigned char*)"", 0);
    assert(sha3_empty != NULL);
    printf("  SHA3-256 empty: %s\n", sha3_empty);
    assert(strcmp(sha3_empty, "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a") == 0);
    free(sha3_empty);
    
    printf("  ✓ Empty input tests passed\n");
}

// TEST-3: Interoperability Test
void test_interoperability() {
    printf("Testing interoperability with system tools...\n");
    
    // Создаем тестовый файл
    FILE* f = fopen("interop_test.txt", "w");
    assert(f != NULL);
    fprintf(f, "Hello, World!\n");
    fclose(f);
    
    // Вычисляем хеш с помощью cryptocore
    char* cc_hash = sha256_file("interop_test.txt");
    assert(cc_hash != NULL);
    
    // Вычисляем хеш с помощью sha256sum
    system("sha256sum interop_test.txt | cut -d' ' -f1 > sys_hash.txt");
    
    FILE* sys = fopen("sys_hash.txt", "r");
    assert(sys != NULL);
    char sys_hash[65];
    fscanf(sys, "%64s", sys_hash);
    fclose(sys);
    
    printf("  CryptoCore hash: %s\n", cc_hash);
    printf("  System hash:     %s\n", sys_hash);
    
    // Сравниваем хеши
    assert(strcmp(cc_hash, sys_hash) == 0);
    
    // Очистка
    free(cc_hash);
    remove("interop_test.txt");
    remove("sys_hash.txt");
    
    printf("  ✓ Interoperability test passed\n");
}

// TEST-4: Large File Test (симуляция)
void test_large_file_simulation() {
    printf("Testing large file handling (simulation)...\n");
    
    // Создаем файл размером 10MB для тестирования
    const size_t LARGE_SIZE = 10 * 1024 * 1024; // 10MB
    FILE* large = fopen("large_test.bin", "wb");
    assert(large != NULL);
    
    // Заполняем случайными данными
    unsigned char buffer[4096];
    for (size_t i = 0; i < sizeof(buffer); i++) {
        buffer[i] = (unsigned char)(i % 256);
    }
    
    size_t written = 0;
    while (written < LARGE_SIZE) {
        size_t chunk = (LARGE_SIZE - written < sizeof(buffer)) ? 
                      LARGE_SIZE - written : sizeof(buffer);
        size_t result = fwrite(buffer, 1, chunk, large);
        assert(result == chunk);
        written += chunk;
    }
    fclose(large);
    
    // Вычисляем хеш
    char* hash = sha256_file("large_test.bin");
    assert(hash != NULL);
    
    // Проверяем, что хеш не нулевой
    assert(strlen(hash) == 64);
    
    printf("  Large file hash (first 16 chars): %.16s...\n", hash);
    printf("  File size: %zu bytes\n", written);
    
    free(hash);
    remove("large_test.bin");
    
    printf("  ✓ Large file test passed\n");
}

// TEST-5: Avalanche Effect Test
void test_avalanche_effect() {
    printf("Testing avalanche effect...\n");
    
    // Два сообщения, отличающиеся одним битом
    unsigned char data1[] = "Hello";
    unsigned char data2[] = "Jello"; // H(0x48) -> J(0x4A), изменен 1 бит
    
    char* hash1 = sha256_hex(data1, 5);
    char* hash2 = sha256_hex(data2, 5);
    
    assert(hash1 != NULL);
    assert(hash2 != NULL);
    
    printf("  Hash 1 (Hello): %s\n", hash1);
    printf("  Hash 2 (Jello): %s\n", hash2);
    
    // Преобразуем hex в бинарное представление
    unsigned char bin1[32], bin2[32];
    for (int i = 0; i < 32; i++) {
        sscanf(hash1 + i*2, "%2hhx", &bin1[i]);
        sscanf(hash2 + i*2, "%2hhx", &bin2[i]);
    }
    
    // Подсчитываем различающиеся биты
    int diff_bits = 0;
    for (int i = 0; i < 32; i++) {
        unsigned char xor = bin1[i] ^ bin2[i];
        while (xor) {
            diff_bits += xor & 1;
            xor >>= 1;
        }
    }
    
    printf("  Different bits: %d/256 (%.1f%%)\n", diff_bits, (diff_bits * 100.0) / 256);
    
    // Avalanche effect: должно быть примерно 128 бит (50%)
    // Принимаем от 100 до 156 бит (39% - 61%)
    assert(diff_bits >= 100 && diff_bits <= 156);
    
    free(hash1);
    free(hash2);
    
    printf("  ✓ Avalanche effect test passed\n");
}

// TEST-6: Performance Test (базовый)
void test_performance_basic() {
    printf("Testing basic performance...\n");
    
    // Создаем тестовый файл 1MB
    const size_t SIZE = 1024 * 1024;
    FILE* perf = fopen("perf_test.bin", "wb");
    assert(perf != NULL);
    
    for (size_t i = 0; i < SIZE; i++) {
        fputc((unsigned char)(i % 256), perf);
    }
    fclose(perf);
    
    // Измеряем время выполнения (очень приблизительно)
    clock_t start = clock();
    char* hash = sha256_file("perf_test.bin");
    clock_t end = clock();
    
    assert(hash != NULL);
    
    double cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;
    double speed = SIZE / cpu_time / 1024 / 1024; // MB/s
    
    printf("  File size: %zu bytes\n", SIZE);
    printf("  CPU time: %.3f seconds\n", cpu_time);
    printf("  Speed: %.2f MB/s\n", speed);
    printf("  Hash: %.16s...\n", hash);
    
    // Проверяем, что производительность разумная
    // (хотя бы 0.1 MB/s для программной реализации)
    assert(speed > 0.1);
    
    free(hash);
    remove("perf_test.bin");
    
    printf("  ✓ Performance test passed\n");
}

int main() {
    printf("=== Hash Function Requirements Tests ===\n\n");
    
    test_empty_input();
    printf("\n");
    
    test_interoperability();
    printf("\n");
    
    test_large_file_simulation();
    printf("\n");
    
    test_avalanche_effect();
    printf("\n");
    
    test_performance_basic();
    
    printf("\n=== All hash requirements tests passed! ===\n");
    return 0;
}```

### Тестовый файл: tests/src/test_roundtrip.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "../../include/crypto.h"
#include "../../include/csprng.h"

void test_roundtrip_mode(const char* mode_name, cipher_mode_t mode, int requires_iv) {
    printf("Testing %s mode... ", mode_name);
    
    // Generate random key and IV
    unsigned char key[16];
    unsigned char iv[16];
    
    assert(generate_random_bytes(key, 16) == 0);
    if (requires_iv) {
        assert(generate_random_bytes(iv, 16) == 0);
    }
    
    // Create test data
    unsigned char test_data_15[] = "15 bytes test!!";
    
    size_t encrypted_len, decrypted_len;
    unsigned char* encrypted = NULL;
    unsigned char* decrypted = NULL;
    
    // Test with 15 bytes (requires padding for ECB/CBC)
    if (requires_iv) {
        switch(mode) {
            case CIPHER_MODE_CBC:
                encrypted = aes_cbc_encrypt(test_data_15, 15, key, iv, &encrypted_len);
                if (encrypted) decrypted = aes_cbc_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
                break;
            case CIPHER_MODE_CFB:
                encrypted = aes_cfb_encrypt(test_data_15, 15, key, iv, &encrypted_len);
                if (encrypted) decrypted = aes_cfb_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
                break;
            case CIPHER_MODE_OFB:
                encrypted = aes_ofb_encrypt(test_data_15, 15, key, iv, &encrypted_len);
                if (encrypted) decrypted = aes_ofb_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
                break;
            case CIPHER_MODE_CTR:
                encrypted = aes_ctr_encrypt(test_data_15, 15, key, iv, &encrypted_len);
                if (encrypted) decrypted = aes_ctr_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
                break;
            default:
                printf("Unknown mode\n");
                return;
        }
    } else {
        // ECB mode
        encrypted = aes_ecb_encrypt(test_data_15, 15, key, &encrypted_len);
        if (encrypted) decrypted = aes_ecb_decrypt(encrypted, encrypted_len, key, &decrypted_len);
    }
    
    assert(encrypted != NULL);
    assert(decrypted != NULL);
    assert(decrypted_len == 15);
    assert(memcmp(test_data_15, decrypted, 15) == 0);
    
    free(encrypted);
    free(decrypted);
    
    printf("✓\n");
}

int main() {
    printf("=== CryptoCore Round-trip Tests ===\n\n");
    
    test_roundtrip_mode("ECB", CIPHER_MODE_ECB, 0);
    test_roundtrip_mode("CBC", CIPHER_MODE_CBC, 1);
    test_roundtrip_mode("CFB", CIPHER_MODE_CFB, 1);
    test_roundtrip_mode("OFB", CIPHER_MODE_OFB, 1);
    test_roundtrip_mode("CTR", CIPHER_MODE_CTR, 1);
    
    printf("\n=== All round-trip tests passed! ===\n");
    return 0;
}```

### Скрипт тестирования: tests/scripts/debug_test.sh
```bash
#!/bin/bash

# Debug script to test individual modes

set -e

BIN_PATH="../bin/cryptocore"
TEST_DIR="../data/test_files"
KEY="00112233445566778899aabbccddeeff"
IV="aabbccddeeff00112233445566778899"

mkdir -p "$TEST_DIR"

# Create test file
echo "Hello, CryptoCore! This is a test." > "$TEST_DIR/debug_test.txt"

test_single_mode() {
    local mode=$1
    local input_file="$TEST_DIR/debug_test.txt"
    local encrypted_file="$TEST_DIR/debug_$mode.enc"
    local decrypted_file="$TEST_DIR/debug_$mode.dec"
    
    echo "=== Testing $mode mode ==="
    
    # Clean up
    rm -f "$encrypted_file" "$decrypted_file"
    
    # Encrypt
    echo "Encrypting..."
    if "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file"; then
        echo "✓ Encryption successful"
        echo "Encrypted file size: $(stat -c%s "$encrypted_file") bytes"
        
        # Show first 32 bytes of encrypted file in hex
        echo "First 32 bytes (hex):"
        xxd -l 32 "$encrypted_file"
    else
        echo "✗ Encryption failed"
        return 1
    fi
    
    # Decrypt
    echo "Decrypting..."
    if [ "$mode" = "ecb" ]; then
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "✓ Decryption successful"
        else
            echo "✗ Decryption failed"
            return 1
        fi
    else
        # Try both with and without IV
        echo "Trying decryption without IV (read from file)..."
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "✓ Decryption successful (IV from file)"
        else
            echo "Trying decryption with explicit IV..."
            if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$encrypted_file" -output "$decrypted_file"; then
                echo "✓ Decryption successful (with explicit IV)"
            else
                echo "✗ All decryption attempts failed"
                return 1
            fi
        fi
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null; then
        echo "✓ Round-trip successful - files are identical"
        return 0
    else
        echo "✗ Round-trip failed - files differ"
        echo "Original: $(stat -c%s "$input_file") bytes"
        echo "Decrypted: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test specific mode or all
if [ $# -eq 1 ]; then
    test_single_mode "$1"
else
    echo "Usage: $0 [mode]"
    echo "Modes: ecb, cbc, cfb, ofb, ctr"
    echo ""
    echo "Available tests:"
    echo "  ./test_roundtrip.sh    - Basic round-trip tests"
    echo "  ./test_interoperability.sh - OpenSSL compatibility tests"
    echo "  ./debug_test.sh [mode] - Debug individual mode"
fi```

### Скрипт тестирования: tests/scripts/fixed_interop_test.sh
```bash
#!/bin/bash

# Fixed Interoperability Test Script

echo "=== Fixed CryptoCore OpenSSL Interoperability Test ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="$KEY_HEX"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    echo "Please build the project first using 'make' in the root directory"
    exit 1
fi

# Create test directory
mkdir -p ../data/test_files
cd ../data/test_files

# Create test file with specific size (multiple of 16 bytes for no-padding tests)
echo -n "0123456789ABCDEF" > "test_16.txt"  # 16 bytes
echo "This is a test file for CryptoCore interoperability testing." > "test_text.txt"

echo "=== Testing Round-trip First ==="

# Test round-trip for all modes
for mode in ecb cbc cfb ofb ctr; do
    echo "Testing $mode round-trip..."
    "$BIN" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "test_16.txt" -output "test_${mode}.enc"
    "$BIN" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "test_${mode}.enc" -output "test_${mode}.dec"
    
    if diff "test_16.txt" "test_${mode}.dec" > /dev/null; then
        echo "✓ $mode round-trip OK"
    else
        echo "✗ $mode round-trip FAILED"
    fi
done

echo ""
echo "=== Testing OpenSSL Interoperability ==="

# Test 1: CryptoCore -> OpenSSL (ECB)
echo "1. CryptoCore -> OpenSSL (ECB)"
"$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "test_16.txt" -output "cc_ecb.enc"

# OpenSSL decryption
if openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "cc_ecb.enc" -out "os_ecb.dec" -nopad 2>/dev/null; then
    if diff "test_16.txt" "os_ecb.dec" > /dev/null; then
        echo "   ✓ ECB: CryptoCore -> OpenSSL OK"
    else
        echo "   ✗ ECB: CryptoCore -> OpenSSL FAILED - files differ"
        echo "   Original size: $(stat -c%s test_16.txt), Decrypted: $(stat -c%s os_ecb.dec)"
    fi
else
    echo "   ✗ ECB: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
fi

# Test 2: OpenSSL -> CryptoCore (ECB)  
echo "2. OpenSSL -> CryptoCore (ECB)"
if openssl enc -aes-128-ecb -K "$KEY_HEX" -in "test_16.txt" -out "os_ecb.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "os_ecb.enc" -output "cc_ecb.dec"

    if diff "test_16.txt" "cc_ecb.dec" > /dev/null; then
        echo "   ✓ ECB: OpenSSL -> CryptoCore OK"
    else
        echo "   ✗ ECB: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   ✗ ECB: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test 3: CryptoCore -> OpenSSL (CBC)
echo "3. CryptoCore -> OpenSSL (CBC)"
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_16.txt" -output "cc_cbc.enc"

# Extract IV and ciphertext
dd if="cc_cbc.enc" of="iv.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc.enc" of="ciphertext.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv.bin" ] && [ -f "ciphertext.bin" ]; then
    IV_FROM_FILE=$(xxd -p "iv.bin" | tr -d '\n')

    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "ciphertext.bin" -out "os_cbc.dec" -nopad 2>/dev/null; then
        if diff "test_16.txt" "os_cbc.dec" > /dev/null; then
            echo "   ✓ CBC: CryptoCore -> OpenSSL OK"
        else
            echo "   ✗ CBC: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   ✗ CBC: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   ✗ CBC: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Test 4: OpenSSL -> CryptoCore (CBC)
echo "4. OpenSSL -> CryptoCore (CBC)"
if openssl enc -aes-128-cbc -K "$KEY_HEX" -iv "00000000000000000000000000000000" -in "test_16.txt" -out "os_cbc.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -iv "00000000000000000000000000000000" -input "os_cbc.enc" -output "cc_cbc.dec"

    if diff "test_16.txt" "cc_cbc.dec" > /dev/null; then
        echo "   ✓ CBC: OpenSSL -> CryptoCore OK"
    else
        echo "   ✗ CBC: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   ✗ CBC: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test with text files (with padding)
echo ""
echo "=== Testing with Padding ==="

# CryptoCore CBC with text (auto padding)
echo "Testing CBC with padding..."
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_text.txt" -output "cc_cbc_pad.enc"

# Extract IV and ciphertext
dd if="cc_cbc_pad.enc" of="iv_pad.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc_pad.enc" of="ciphertext_pad.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv_pad.bin" ] && [ -f "ciphertext_pad.bin" ]; then
    IV_PAD=$(xxd -p "iv_pad.bin" | tr -d '\n')

    # OpenSSL decryption with padding (no -nopad flag)
    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_PAD" -in "ciphertext_pad.bin" -out "os_cbc_pad.dec" 2>/dev/null; then
        if diff "test_text.txt" "os_cbc_pad.dec" > /dev/null; then
            echo "   ✓ CBC with padding: CryptoCore -> OpenSSL OK"
        else
            echo "   ✗ CBC with padding: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   ✗ CBC with padding: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   ✗ CBC with padding: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Cleanup
cd ../../..
rm -rf ../data/test_files

echo ""
echo "=== Interoperability Test Complete ==="```

### Скрипт тестирования: tests/scripts/openssl_safe_test.sh
```bash
#!/bin/bash

echo "=== OPENSSL SAFE TEST (без удаления файлов) ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="$KEY_HEX"

# Создаем временную директорию для OpenSSL тестов
mkdir -p ../data/openssl_temp
cd ../data/openssl_temp

# Копируем тестовый файл
cp ../test_files/test_16_bytes.txt .

echo "Тестирую ECB с OpenSSL..."
# Шифруем CryptoCore
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_16_bytes.txt -output cc_ecb.enc

# Пытаемся расшифровать OpenSSL
if openssl enc -aes-128-ecb -d -K $KEY_HEX -in cc_ecb.enc -out openssl_ecb.dec -nopad 2>/dev/null; then
    if diff test_16_bytes.txt openssl_ecb.dec > /dev/null; then
        echo "✅ ECB: CryptoCore -> OpenSSL РАБОТАЕТ"
    else
        echo "❌ ECB: CryptoCore -> OpenSSL НЕ РАБОТАЕТ - файлы отличаются"
        echo "Оригинал: $(xxd -l 16 test_16_bytes.txt)"
        echo "OpenSSL:  $(xxd -l 16 openssl_ecb.dec)"
    fi
else
    echo "❌ ECB: OpenSSL не смог расшифровать"
fi

echo
echo "Тестирую CBC с OpenSSL..."
# Шифруем CryptoCore
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_16_bytes.txt -output cc_cbc.enc

# Извлекаем IV
dd if=cc_cbc.enc of=iv.bin bs=16 count=1 status=none 2>/dev/null
dd if=cc_cbc.enc of=ciphertext.bin bs=16 skip=1 status=none 2>/dev/null

if [ -f iv.bin ] && [ -f ciphertext.bin ]; then
    IV_HEX=$(xxd -p iv.bin | tr -d '\n')
    
    if openssl enc -aes-128-cbc -d -K $KEY_HEX -iv $IV_HEX -in ciphertext.bin -out openssl_cbc.dec -nopad 2>/dev/null; then
        if diff test_16_bytes.txt openssl_cbc.dec > /dev/null; then
            echo "✅ CBC: CryptoCore -> OpenSSL РАБОТАЕТ"
        else
            echo "❌ CBC: CryptoCore -> OpenSSL НЕ РАБОТАЕТ - файлы отличаются"
        fi
    else
        echo "❌ CBC: OpenSSL не смог расшифровать"
    fi
else
    echo "❌ CBC: Не удалось извлечь IV или шифртекст"
fi

# Возвращаемся и очищаем
cd ../../..
rm -rf ../data/openssl_temp

echo "=== OPENSSL ТЕСТ ЗАВЕРШЕН ==="```

### Скрипт тестирования: tests/scripts/padding_test.sh
```bash
#!/bin/bash

# Padding Test Script

echo "=== Padding Test ==="

BIN="../bin/cryptocore"
KEY="00112233445566778899aabbccddeeff"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    exit 1
fi

mkdir -p ../data/padding_test
cd ../data/padding_test

# Create test files of different sizes
echo -n "15_bytes_____" > "15.txt"  # 15 bytes
echo -n "16_bytes_______" > "16.txt"  # 16 bytes  
echo -n "17_bytes________" > "17.txt"  # 17 bytes
echo -n "31_bytes_______________________" > "31.txt"  # 31 bytes
echo -n "32_bytes______________________________" > "32.txt"  # 32 bytes

echo "Testing padding for different file sizes..."

for file in 15.txt 16.txt 17.txt 31.txt 32.txt; do
    size=$(stat -c%s "$file")
    echo "File: $file ($size bytes)"
    
    # Test ECB (requires padding)
    if "$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.ecb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "${file%.txt}.ecb.enc" -output "${file%.txt}.ecb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.ecb.dec" > /dev/null; then
            echo "  ✓ ECB padding OK"
        else
            echo "  ✗ ECB padding FAILED"
        fi
    else
        echo "  ✗ ECB padding FAILED - encryption/decryption error"
    fi
    
    # Test CBC (requires padding)
    if "$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cbc.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -input "${file%.txt}.cbc.enc" -output "${file%.txt}.cbc.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cbc.dec" > /dev/null; then
            echo "  ✓ CBC padding OK"
        else
            echo "  ✗ CBC padding FAILED"
        fi
    else
        echo "  ✗ CBC padding FAILED - encryption/decryption error"
    fi
    
    # Test CFB (no padding)
    if "$BIN" -algorithm aes -mode cfb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cfb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cfb -decrypt -key "$KEY" -input "${file%.txt}.cfb.enc" -output "${file%.txt}.cfb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cfb.dec" > /dev/null; then
            echo "  ✓ CFB no-padding OK"
        else
            echo "  ✗ CFB no-padding FAILED"
        fi
    else
        echo "  ✗ CFB no-padding FAILED - encryption/decryption error"
    fi
    
    echo ""
done

cd ../../..
rm -rf ../data/padding_test

echo "=== Padding Test Complete ==="```

### Скрипт тестирования: tests/scripts/run_all_tests.sh
```bash
#!/bin/bash

echo "=========================================="
echo "     CryptoCore Complete Test Suite      "
echo "=========================================="

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to run test with output
run_test() {
    local test_name="$1"
    local test_cmd="$2"
    
    echo -e "\n${YELLOW}▶ Running: $test_name${NC}"
    echo "------------------------------------------"
    
    if eval "$test_cmd"; then
        echo -e "${GREEN}✓ $test_name PASSED${NC}"
        return 0
    else
        echo -e "${RED}✗ $test_name FAILED${NC}"
        return 1
    fi
}

# Build everything first
echo -e "\n${YELLOW}Building project...${NC}"
make clean
if ! make all; then
    echo -e "${RED}Build failed!${NC}"
    exit 1
fi

echo -e "${GREEN}Build successful!${NC}"

# Run tests
failed=0
passed=0

# Unit tests
run_test "CSPRNG Unit Tests" "../bin/test_csprng" && ((passed++)) || ((failed++))
run_test "Round-trip Unit Tests" "../bin/test_roundtrip" && ((passed++)) || ((failed++))

# Integration tests
run_test "Round-trip Integration" "./test_roundtrip.sh" && ((passed++)) || ((failed++))
run_test "Key Generation Tests" "./test_key_generation.sh" && ((passed++)) || ((failed++))
run_test "OpenSSL Interoperability" "./test_interoperability.sh" && ((passed++)) || ((failed++))

# Optional tests
echo -e "\n${YELLOW}▶ Optional tests:${NC}"
run_test "Padding Tests" "./padding_test.sh" && ((passed++)) || ((failed++))

# Summary
echo "=========================================="
echo "           TEST SUMMARY"
echo "=========================================="
echo -e "Total tests: $((passed + failed))"
echo -e "${GREEN}Passed: $passed${NC}"
if [ $failed -gt 0 ]; then
    echo -e "${RED}Failed: $failed${NC}"
else
    echo -e "${GREEN}All tests passed!${NC}"
fi

# Cleanup
echo -e "\n${YELLOW}Cleaning up test files...${NC}"
make clean > /dev/null 2>&1
rm -f ../data/*.enc ../data/*.dec ../data/test_*.txt 2>/dev/null

exit $failed```

### Скрипт тестирования: tests/scripts/run_nist_tests.sh
```bash
#!/bin/bash

echo "=== NIST Statistical Test Suite Runner ==="

# Check if NIST STS is available
NIST_DIR="../../../sts-2.1.2"
NIST_BIN="$NIST_DIR/assess"

if [ ! -f "$NIST_BIN" ]; then
    echo "Error: NIST STS not found at $NIST_DIR"
    echo "Please download and compile NIST STS first:"
    echo "1. Download from https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"
    echo "2. Extract to sts-2.1.2 directory in project root"
    echo "3. Run 'make' in the sts-2.1.2 directory"
    echo ""
    echo "For now, we'll generate the test data for manual NIST testing."
    echo "You can run NIST tests later when you install the test suite."
fi

echo "Generating test data for NIST..."
../bin/test_csprng

TEST_DATA="../results/nist_test_data.bin"
if [ ! -f "$TEST_DATA" ]; then
    echo "Error: Failed to generate test data"
    exit 1
fi

echo "✓ Test data ready: $TEST_DATA ($(stat -c%s "$TEST_DATA") bytes)"

if [ -f "$NIST_BIN" ]; then
    echo "Running NIST Statistical Test Suite..."
    cd "$NIST_DIR"

    # Create assessment configuration
    cat > assess_config.txt << EOF
../../tests/$TEST_DATA
0
1
1000000
EOF

    ./assess 1000000 < assess_config.txt

    echo ""
    echo "=== NIST Tests Complete ==="
    echo "Results available in: $NIST_DIR/experiments/AlgorithmTesting/finalAnalysisReport.txt"
    echo "Summary of results:"

    # Extract and display summary
    if [ -f "experiments/AlgorithmTesting/finalAnalysisReport.txt" ]; then
        grep -E "(TEST|passed|failed)" "experiments/AlgorithmTesting/finalAnalysisReport.txt" | head -20
    fi
else
    echo ""
    echo "=== NIST Test Data Generated ==="
    echo "Test file: $TEST_DATA"
    echo "To run full NIST tests:"
    echo "1. Download NIST STS from: https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"
    echo "2. Extract and compile: tar -xzf sts-2.1.2.tar.gz && cd sts-2.1.2 && make"
    echo "3. Run: ./assess 1000000"
    echo "4. Use $TEST_DATA as input when prompted"
fi```

### Скрипт тестирования: tests/scripts/run_tests.sh
```bash
#!/bin/bash

echo "=== CryptoCore Comprehensive Tests ==="

BIN="../bin/cryptocore" 
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="$KEY_HEX"          

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    echo "Please build the project first using 'make'"
    exit 1
fi

echo "✓ Binary found: $BIN"

# Create test files in data directory
echo "Creating test files..."
cd ../data
echo "0123456789ABCDEF" > test_16.txt
echo "Test message for padding check" > test_text.txt
cd ../scripts

echo "=== Test 1: Round-trip Tests ==="
for mode in ecb cbc cfb ofb ctr; do
    echo "Testing $mode..."
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input ../data/test_16.txt -output ../data/test_$mode.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input ../data/test_$mode.enc -output ../data/test_$mode.dec
    
    if diff ../data/test_16.txt ../data/test_$mode.dec > /dev/null; then
        echo "  ✅ $mode round-trip PASSED"
    else
        echo "  ❌ $mode round-trip FAILED"
    fi
done

echo ""
echo "=== Test 2: OpenSSL Interoperability ==="

# ECB test
echo "Testing ECB interoperability..."
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input ../data/test_16.txt -output ../data/cc_ecb.enc
openssl enc -aes-128-ecb -d -K $KEY_HEX -in ../data/cc_ecb.enc -out ../data/os_ecb.dec -nopad 2>/dev/null

if diff ../data/test_16.txt ../data/os_ecb.dec > /dev/null; then
    echo "  ✅ ECB interoperability PASSED"
else
    echo "  ❌ ECB interoperability FAILED"
fi

# CBC test  
echo "Testing CBC interoperability..."
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input ../data/test_16.txt -output ../data/cc_cbc.enc
dd if=../data/cc_cbc.enc of=../data/iv.bin bs=16 count=1 status=none 2>/dev/null
dd if=../data/cc_cbc.enc of=../data/ciphertext.bin bs=16 skip=1 status=none 2>/dev/null
IV_HEX=$(xxd -p ../data/iv.bin 2>/dev/null | tr -d '\n')
openssl enc -aes-128-cbc -d -K $KEY_HEX -iv $IV_HEX -in ../data/ciphertext.bin -out ../data/os_cbc.dec -nopad 2>/dev/null

if diff ../data/test_16.txt ../data/os_cbc.dec > /dev/null; then
    echo "  ✅ CBC interoperability PASSED"
else
    echo "  ❌ CBC interoperability FAILED"
fi

echo ""
echo "=== Test 3: Padding Tests ==="
for mode in ecb cbc; do
    echo "Testing $mode with padding..."
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input ../data/test_text.txt -output ../data/pad_$mode.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input ../data/pad_$mode.enc -output ../data/pad_$mode.dec
    
    if diff ../data/test_text.txt ../data/pad_$mode.dec > /dev/null; then
        echo "  ✅ $mode padding PASSED"
    else
        echo "  ❌ $mode padding FAILED"
    fi
done

# Cleanup
echo "Cleaning up..."
rm -f ../data/test_*.txt ../data/*.enc ../data/*.dec ../data/iv.bin ../data/ciphertext.bin

echo ""
echo "=== ALL TESTS COMPLETED ==="```

### Скрипт тестирования: tests/scripts/safe_test.sh
```bash
#!/bin/bash

echo "=== SAFE CRYPTOCORE TESTS (без удаления файлов) ==="

BIN="../bin/cryptocore"
KEY="00112233445566778899aabbccddeeff"

# Проверяем что бинарник существует
if [ ! -f "$BIN" ]; then
    echo "ОШИБКА: cryptocore бинарник не найден!"
    exit 1
fi

echo "✓ Бинарник найден"
echo "✓ Тестовые файлы сохранены"
echo

# Тест 1: Базовые режимы
echo "--- ТЕСТ 1: БАЗОВЫЕ РЕЖИМЫ ---"
for mode in ecb cbc cfb ofb ctr; do
    echo -n "Тестирую $mode... "
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input ../data/test_files/test1.txt -output ../data/test_${mode}.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input ../data/test_${mode}.enc -output ../data/test_${mode}.dec
    
    if diff ../data/test_files/test1.txt ../data/test_${mode}.dec > /dev/null 2>&1; then
        echo "✅ УСПЕХ"
    else
        echo "❌ ОШИБКА"
    fi
done

echo

# Тест 2: Разные размеры файлов
echo "--- ТЕСТ 2: РАЗНЫЕ РАЗМЕРЫ ФАЙЛОВ ---"
echo -n "16 байт (без padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input ../data/test_files/test_16_bytes.txt -output ../data/test_16_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input ../data/test_16_enc.enc -output ../data/test_16_dec.txt
diff ../data/test_files/test_16_bytes.txt ../data/test_16_dec.txt > /dev/null 2>&1 && echo "✅ УСПЕХ" || echo "❌ ОШИБКА"

echo -n "15 байт (требует padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input ../data/test_files/test_15_bytes.txt -output ../data/test_15_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input ../data/test_15_enc.enc -output ../data/test_15_dec.txt
diff ../data/test_files/test_15_bytes.txt ../data/test_15_dec.txt > /dev/null 2>&1 && echo "✅ УСПЕХ" || echo "❌ ОШИБКА"

echo

# Тест 3: Бинарные файлы
echo "--- ТЕСТ 3: БИНАРНЫЕ ФАЙЛЫ ---"
echo -n "Случайные данные... "
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input ../data/test_files/random_binary.bin -output ../data/test_bin_enc.enc
$BIN -algorithm aes -mode cbc -decrypt -key $KEY -input ../data/test_bin_enc.enc -output ../data/test_bin_dec.bin
diff ../data/test_files/random_binary.bin ../data/test_bin_dec.bin > /dev/null 2>&1 && echo "✅ УСПЕХ" || echo "❌ ОШИБКА"

echo

# Тест 4: IV работа
echo "--- ТЕСТ 4: ПРОВЕРКА IV ---"
echo "Шифруем CBC с автоматическим IV..."
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input ../data/test_files/test1.txt -output ../data/test_cbc_iv.enc
echo "Размер зашифрованного файла: $(stat -c%s ../data/test_cbc_iv.enc) байт"
echo "Первые 32 байта (hex):"
xxd -l 32 ../data/test_cbc_iv.enc

echo

# Очищаем только временные файлы тестов (не оригинальные тестовые файлы)
echo "Очищаю временные файлы тестов..."
rm -f ../data/test_*.enc ../data/test_*.dec ../data/test_*.bin

echo "=== ТЕСТИРОВАНИЕ ЗАВЕРШЕНО ==="
echo "✓ Оригинальные тестовые файлы сохранены в ../data/test_files/"
echo "✓ Все временные файлы удалены"```

### Скрипт тестирования: tests/scripts/test_interoperability.sh
```bash
#!/bin/bash

# CryptoCore OpenSSL Interoperability Test Script
# Tests compatibility between CryptoCore and OpenSSL

set -e

echo "=== CryptoCore OpenSSL Interoperability Tests ==="
echo

BIN_PATH="../bin/cryptocore"
TEST_DIR="../data/test_files"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="$KEY_HEX"
IV_HEX="aabbccddeeff00112233445566778899"
IV="$IV_HEX"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Check if OpenSSL is available
if ! command -v openssl &> /dev/null; then
    echo -e "${RED}Error: openssl command not found${NC}"
    echo "Install with: sudo apt-get install openssl"
    exit 1
fi

# Check if xxd is available
if ! command -v xxd &> /dev/null; then
    echo -e "${RED}Error: xxd command not found${NC}"
    echo "Install with: sudo apt-get install xxd"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test file
echo "This is a test file for interoperability testing." > "$TEST_DIR/interop_test.txt"
TEST_FILE_SIZE=$(stat -c%s "$TEST_DIR/interop_test.txt")
echo "Test file size: $TEST_FILE_SIZE bytes"

# Test function for CryptoCore -> OpenSSL
test_cryptocore_to_openssl() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local cryptocore_encrypted="$TEST_DIR/interop_${mode}_cryptocore.enc"
    local iv_file="$TEST_DIR/iv.bin"
    local ciphertext_only="$TEST_DIR/ciphertext_only.bin"
    local openssl_decrypted="$TEST_DIR/decrypted_openssl.txt"
    
    echo "Testing CryptoCore -> OpenSSL for $mode mode..."
    
    # Clean up any existing files
    rm -f "$cryptocore_encrypted" "$iv_file" "$ciphertext_only" "$openssl_decrypted"
    
    # Encrypt with CryptoCore
    echo "Encrypting with CryptoCore..."
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$cryptocore_encrypted" 2>/dev/null; then
        echo -e "${RED}FAIL: CryptoCore encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$cryptocore_encrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore encrypted file not created for $mode${NC}"
        return 1
    fi
    
    local encrypted_size=$(stat -c%s "$cryptocore_encrypted")
    echo "CryptoCore encrypted file size: $encrypted_size bytes"
    
    if [ "$mode" != "ecb" ]; then
        # Extract IV and ciphertext for modes that use IV
        echo "Extracting IV and ciphertext..."
        dd if="$cryptocore_encrypted" of="$iv_file" bs=16 count=1 status=none
        dd if="$cryptocore_encrypted" of="$ciphertext_only" bs=16 skip=1 status=none
        
        # Check if extraction worked
        if [ ! -f "$iv_file" ] || [ ! -f "$ciphertext_only" ]; then
            echo -e "${RED}FAIL: Failed to extract IV or ciphertext for $mode${NC}"
            return 1
        fi
        
        # Get IV as hex string
        IV_FROM_FILE=$(xxd -p "$iv_file" | tr -d '\n')
        echo "IV from file: $IV_FROM_FILE"
        
        # Decrypt with OpenSSL
        echo "Decrypting with OpenSSL..."
        if ! openssl enc -aes-128-$openssl_mode -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    else {
        # ECB mode - no IV
        cp "$cryptocore_encrypted" "$ciphertext_only"
        echo "Decrypting ECB with OpenSSL..."
        if ! openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    }
    
    # Check if decrypted file was created
    if [ ! -f "$openssl_decrypted" ]; then
        echo -e "${RED}FAIL: OpenSSL decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$openssl_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: CryptoCore -> OpenSSL successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: CryptoCore -> OpenSSL failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$openssl_decrypted") bytes"
        return 1
    fi
}

# Test function for OpenSSL -> CryptoCore
test_openssl_to_cryptocore() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local openssl_encrypted="$TEST_DIR/interop_${mode}_openssl.enc"
    local cryptocore_decrypted="$TEST_DIR/decrypted_cryptocore.txt"
    
    echo "Testing OpenSSL -> CryptoCore for $mode mode..."
    
    # Clean up any existing files
    rm -f "$openssl_encrypted" "$cryptocore_decrypted"
    
    # Encrypt with OpenSSL
    echo "Encrypting with OpenSSL..."
    if [ "$mode" != "ecb" ]; then
        if ! openssl enc -aes-128-$openssl_mode -K "$KEY_HEX" -iv "$IV_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        # Check if encrypted file was created
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        # Decrypt with CryptoCore using provided IV
        echo "Decrypting with CryptoCore..."
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    else
        # ECB mode - no IV
        if ! openssl enc -aes-128-ecb -K "$KEY_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$cryptocore_decrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$cryptocore_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: OpenSSL -> CryptoCore successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: OpenSSL -> CryptoCore failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$cryptocore_decrypted") bytes"
        return 1
    fi
}

# Clean up before starting
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
openssl_modes=("ecb" "cbc" "cfb" "ofb" "ctr")

passed=0
total=0

echo "=== CryptoCore -> OpenSSL Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_cryptocore_to_openssl "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

echo "=== OpenSSL -> CryptoCore Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_openssl_to_cryptocore "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

# Final cleanup
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin "$TEST_DIR"/interop_test.txt

echo "=== Interoperability Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All interoperability tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some interoperability tests failed!${NC}"
    exit 1
fi```

### Скрипт тестирования: tests/scripts/test_key_generation.sh
```bash
#!/bin/bash

echo "=== Key Generation Integration Test ==="

BIN="../bin/cryptocore"          
TEST_FILE="../data/test_key_gen.txt"

# Create test file
echo "Test data for key generation" > "$TEST_FILE"


echo "1. Testing encryption with auto-generated key..."
output=$("$BIN" -algorithm aes -mode cbc -encrypt -input "$TEST_FILE" -output "../data/encrypted.bin" 2>&1)

# Extract key from output (новый формат без @)
if echo "$output" | grep -q "Generated random key: [0-9a-fA-F]\{32\}"; then
    generated_key=$(echo "$output" | grep "Generated random key: " | cut -d' ' -f4)
    echo "✓ Key generation successful: $generated_key"
    
    # Проверяем что ключ не содержит @
    if echo "$generated_key" | grep -q "@"; then
        echo "✗ Key contains @ prefix - this should not happen!"
        exit 1
    fi
else
    echo "✗ Key generation failed or wrong format"
    echo "Output was: $output"
    exit 1
fi

echo "2. Testing decryption with generated key..."
if "$BIN" -algorithm aes -mode cbc -decrypt -key "$generated_key" -input "../data/encrypted.bin" -output "../data/decrypted.txt"; then
    echo "✓ Decryption with generated key successful"
else
    echo "✗ Decryption with generated key failed"
    exit 1
fi

echo "3. Verifying file integrity..."
if diff "$TEST_FILE" "../data/decrypted.txt" > /dev/null; then
    echo "✓ File integrity verified"
else
    echo "✗ File integrity check failed"
    exit 1
fi

echo "4. Testing that decryption requires key..."
if "$BIN" -algorithm aes -mode cbc -decrypt -input "../data/encrypted.bin" -output "../data/should_fail.txt" 2>/dev/null; then
    echo "✗ Decryption without key should have failed"
    exit 1
else
    echo "✓ Decryption correctly requires key"
fi

# Test with new key format (без @)
echo "5. Testing encryption with explicit key (new format)..."
if "$BIN" -algorithm aes -mode ecb -encrypt -key "$generated_key" -input "$TEST_FILE" -output "../data/explicit_encrypted.bin"; then
    echo "✓ Encryption with explicit key (new format) successful"
else
    echo "✗ Encryption with explicit key failed"
    exit 1
fi

# Cleanup
rm -f "$TEST_FILE" "../data/encrypted.bin" "../data/decrypted.txt" "../data/should_fail.txt" "../data/explicit_encrypted.bin"

echo ""
echo "=== All Key Generation Tests Passed! ==="```

### Скрипт тестирования: tests/scripts/test_roundtrip.sh
```bash
#!/bin/bash

# CryptoCore Round-trip Test Script
# Tests encryption and decryption for all modes

set -e

echo "=== CryptoCore Round-trip Tests ==="
echo

BIN_PATH="../bin/cryptocore"          
TEST_DIR="../data/test_files"         
KEY="00112233445566778899aabbccddeeff"   

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test files
echo "Creating test files..."
echo "This is a test file for CryptoCore." > "$TEST_DIR/test1.txt"
echo "Another test file with different content." > "$TEST_DIR/test2.txt"

# Generate a binary test file
head -c 100 /dev/urandom > "$TEST_DIR/test3.bin"

# Test function
test_mode() {
    local mode=$1
    local input_file="$TEST_DIR/test1.txt"
    local encrypted_file="$TEST_DIR/test1.$mode.enc"
    local decrypted_file="$TEST_DIR/test1.$mode.dec"
    
    echo "Testing $mode mode..."
    
    # Encrypt
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file" 2>/dev/null; then
        echo -e "${RED}FAIL: Encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$encrypted_file" ]; then
        echo -e "${RED}FAIL: Encrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Decrypt
    if [ "$mode" = "ecb" ]; then
        # ECB mode - no IV handling
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    else
        # For other modes, IV is read from file automatically
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$decrypted_file" ]; then
        echo -e "${RED}FAIL: Decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: $mode round-trip successful${NC}"
        # Clean up test files for this mode
        rm -f "$encrypted_file" "$decrypted_file"
        return 0
    else
        echo -e "${RED}FAIL: $mode round-trip failed - files differ${NC}"
        echo "Input file size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted file size: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
passed=0
total=0

echo "Starting round-trip tests..."
echo

for mode in "${modes[@]}"; do
    if test_mode "$mode"; then
        ((passed++))
    else
        # Debug info for failed test
        echo "Debug info for $mode:"
        ls -la "$TEST_DIR"/test1.$mode.* 2>/dev/null || echo "No test files found"
    fi
    ((total++))
    echo
done

# Clean up original test files
rm -f "$TEST_DIR"/test1.txt "$TEST_DIR"/test2.txt "$TEST_DIR"/test3.bin

echo "=== Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some tests failed!${NC}"
    exit 1
fi```

# КОНЕЦ ДАМПА ПРОЕКТА
