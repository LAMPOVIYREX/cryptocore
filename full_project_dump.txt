]633;E;echo "=== PROJECT STRUCTURE ===";32fd46f1-78e7-43c1-a036-cf16797196f1]633;C=== PROJECT STRUCTURE ===
.
â”œâ”€â”€ bin
â”‚Â Â  â””â”€â”€ cryptocore
â”œâ”€â”€ full_project_dump.txt
â”œâ”€â”€ image.png
â”œâ”€â”€ include
â”‚Â Â  â”œâ”€â”€ cli_parser.h
â”‚Â Â  â”œâ”€â”€ crypto.h
â”‚Â Â  â”œâ”€â”€ file_io.h
â”‚Â Â  â””â”€â”€ modes
â”‚Â Â      â””â”€â”€ ecb.h
â”œâ”€â”€ Makefile
â”œâ”€â”€ obj
â”‚Â Â  â”œâ”€â”€ cli_parser.o
â”‚Â Â  â”œâ”€â”€ crypto.o
â”‚Â Â  â”œâ”€â”€ file_io.o
â”‚Â Â  â”œâ”€â”€ main.o
â”‚Â Â  â”œâ”€â”€ modes
â”‚Â Â  â”‚Â Â  â””â”€â”€ ecb.o
â”‚Â Â  â””â”€â”€ modes.o
â”œâ”€â”€ plain.txt
â”œâ”€â”€ README.md
â”œâ”€â”€ run_tests.sh
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ cli_parser.c
â”‚Â Â  â”œâ”€â”€ cli_parser.h
â”‚Â Â  â”œâ”€â”€ common.h
â”‚Â Â  â”œâ”€â”€ crypto.c
â”‚Â Â  â”œâ”€â”€ crypto.h
â”‚Â Â  â”œâ”€â”€ file_io.c
â”‚Â Â  â”œâ”€â”€ file_io.h
â”‚Â Â  â”œâ”€â”€ main.c
â”‚Â Â  â”œâ”€â”€ modes
â”‚Â Â  â”‚Â Â  â””â”€â”€ ecb.c
â”‚Â Â  â”œâ”€â”€ modes.c
â”‚Â Â  â””â”€â”€ types.h
â”œâ”€â”€ tests
â”‚Â Â  â”œâ”€â”€ debug_test.sh
â”‚Â Â  â”œâ”€â”€ fixed_interop_test.sh
â”‚Â Â  â”œâ”€â”€ openssl_safe_test.sh
â”‚Â Â  â”œâ”€â”€ padding_test.sh
â”‚Â Â  â”œâ”€â”€ safe_test.sh
â”‚Â Â  â”œâ”€â”€ test_files
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ binary_test.bin
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_cbc.dec
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_cbc.enc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_cfb.dec
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_cfb.enc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_ecb.dec
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_ecb.enc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug_test.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ random_binary.bin
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test_15_bytes.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test_16_bytes.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test_16.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test1.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ test2.txt
â”‚Â Â  â”‚Â Â  â””â”€â”€ test3.bin
â”‚Â Â  â”œâ”€â”€ test_interoperability.sh
â”‚Â Â  â”œâ”€â”€ test_roundtrip.c
â”‚Â Â  â””â”€â”€ test_roundtrip.sh
â””â”€â”€ .vscode
    â””â”€â”€ settings.json

10 directories, 52 files

=== MAKEFILE ===
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -O2
LDFLAGS = -lcrypto

SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin

SOURCES = $(wildcard $(SRC_DIR)/*.c)
OBJECTS = $(SOURCES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
TARGET = $(BIN_DIR)/cryptocore

TEST_SRC = tests/test_roundtrip.c
TEST_OBJ = $(OBJ_DIR)/test_roundtrip.o
TEST_TARGET = $(BIN_DIR)/test_roundtrip

.PHONY: all clean test

all: $(TARGET)

$(TARGET): $(OBJECTS) | $(BIN_DIR)
	$(CC) $(OBJECTS) -o $@ $(LDFLAGS)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

$(BIN_DIR):
	mkdir -p $(BIN_DIR)

test: $(TEST_TARGET)
	./$(TEST_TARGET)

$(TEST_TARGET): $(TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) | $(BIN_DIR)
	$(CC) $(TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) -o $@ $(LDFLAGS)

clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)

install-dependencies:
	sudo apt-get update
	sudo apt-get install libssl-dev
=== README ===
# CryptoCore

A command-line tool for AES encryption and decryption supporting multiple modes of operation (ECB, CBC, CFB, OFB, CTR).

## Features

- **Algorithms**: AES-128
- **Modes**: ECB, CBC, CFB, OFB, CTR
- **Padding**: PKCS#7 (for ECB and CBC modes)
- **Key Format**: Hexadecimal string (16 bytes for AES-128)
- **IV Handling**: Automatic generation for encryption, file-based or argument for decryption

## Build Instructions

### Prerequisites

- GCC compiler
- OpenSSL development libraries

### On Ubuntu/Debian:
```bash
sudo apt-get update
sudo apt-get install build-essential libssl-dev
=== SOURCE FILES (.c) ===

--- src/cli_parser.c ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "types.h"
#include "cli_parser.h"

void print_usage(const char* program_name) {
    fprintf(stderr, "Usage: %s -algorithm aes -mode [ecb|cbc|cfb|ofb|ctr] (-encrypt | -decrypt) -key @HEX_KEY -input INPUT_FILE [-output OUTPUT_FILE] [-iv @HEX_IV]\n", program_name);
    fprintf(stderr, "Examples:\n");
    fprintf(stderr, "  Encryption: %s -algorithm aes -mode cbc -encrypt -key @00112233445566778899aabbccddeeff -input plain.txt -output cipher.bin\n", program_name);
    fprintf(stderr, "  Decryption: %s -algorithm aes -mode cbc -decrypt -key @00112233445566778899aabbccddeeff -iv @aabbccddeeff00112233445566778899 -input cipher.bin -output decrypted.txt\n", program_name);
    fprintf(stderr, "Supported modes: ecb, cbc, cfb, ofb, ctr\n");
}

cipher_mode_t parse_cipher_mode(const char* mode_str) {
    if (strcmp(mode_str, "ecb") == 0) return CIPHER_MODE_ECB;
    if (strcmp(mode_str, "cbc") == 0) return CIPHER_MODE_CBC;
    if (strcmp(mode_str, "cfb") == 0) return CIPHER_MODE_CFB;
    if (strcmp(mode_str, "ofb") == 0) return CIPHER_MODE_OFB;
    if (strcmp(mode_str, "ctr") == 0) return CIPHER_MODE_CTR;
    return CIPHER_MODE_UNKNOWN;
}

int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len) {
    if (hex_str[0] != '@') {
        fprintf(stderr, "Error: Hexadecimal value must start with '@' followed by hexadecimal characters\n");
        return 0;
    }
    
    const char* hex_data = hex_str + 1;
    size_t hex_len = strlen(hex_data);
    
    if (hex_len == 0 || hex_len % 2 != 0) {
        fprintf(stderr, "Error: Hexadecimal value must have even number of digits\n");
        return 0;
    }
    
    *len = hex_len / 2;
    *bytes = malloc(*len);
    if (*bytes == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        return 0;
    }
    
    for (size_t i = 0; i < *len; i++) {
        if (sscanf(hex_data + 2*i, "%2hhx", &(*bytes)[i]) != 1) {
            fprintf(stderr, "Error: Invalid hexadecimal character\n");
            free(*bytes);
            *bytes = NULL;
            return 0;
        }
    }
    
    return 1;
}

int parse_arguments(int argc, char* argv[], cli_args_t* args) {
    memset(args, 0, sizeof(cli_args_t));
    args->operation = MODE_UNKNOWN;
    args->mode = CIPHER_MODE_UNKNOWN;
    
    int encrypt_flag = 0;
    int decrypt_flag = 0;
    char* mode_str = NULL;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-algorithm") == 0 && i + 1 < argc) {
            args->algorithm = malloc(strlen(argv[i+1]) + 1);
            if (args->algorithm) strcpy(args->algorithm, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-mode") == 0 && i + 1 < argc) {
            mode_str = malloc(strlen(argv[i+1]) + 1);
            if (mode_str) strcpy(mode_str, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-encrypt") == 0) {
            encrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-decrypt") == 0) {
            decrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-key") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->key, &args->key_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            i++;
        }
        else if (strcmp(argv[i], "-iv") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->iv, &args->iv_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            args->iv_provided = 1;
            i++;
        }
        else if (strcmp(argv[i], "-input") == 0 && i + 1 < argc) {
            args->input_file = malloc(strlen(argv[i+1]) + 1);
            if (args->input_file) strcpy(args->input_file, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-output") == 0 && i + 1 < argc) {
            args->output_file = malloc(strlen(argv[i+1]) + 1);
            if (args->output_file) strcpy(args->output_file, argv[i+1]);
            i++;
        }
        else {
            fprintf(stderr, "Error: Unknown argument '%s'\n", argv[i]);
            print_usage(argv[0]);
            if (mode_str) free(mode_str);
            return 0;
        }
    }
    
    // Parse cipher mode
    if (mode_str) {
        args->mode = parse_cipher_mode(mode_str);
        free(mode_str);
    }
    
    // Set operation mode based on flags
    if (encrypt_flag && decrypt_flag) {
        fprintf(stderr, "Error: Cannot specify both -encrypt and -decrypt\n");
        return 0;
    }
    else if (encrypt_flag) {
        args->operation = MODE_ENCRYPT;
    }
    else if (decrypt_flag) {
        args->operation = MODE_DECRYPT;
    }
    
    // Validation
    if (args->algorithm == NULL || strcmp(args->algorithm, "aes") != 0) {
        fprintf(stderr, "Error: Algorithm must be 'aes'\n");
        return 0;
    }
    
    if (args->mode == CIPHER_MODE_UNKNOWN) {
        fprintf(stderr, "Error: Mode must be one of: ecb, cbc, cfb, ofb, ctr\n");
        return 0;
    }
    
    if (args->operation == MODE_UNKNOWN) {
        fprintf(stderr, "Error: Must specify either -encrypt or -decrypt\n");
        return 0;
    }
    
    if (args->key == NULL) {
        fprintf(stderr, "Error: Key is required\n");
        return 0;
    }
    
    if (args->key_len != 16) {
        fprintf(stderr, "Error: Key must be 16 bytes for AES-128\n");
        return 0;
    }
    
    if (args->input_file == NULL) {
        fprintf(stderr, "Error: Input file is required\n");
        return 0;
    }
    
    // IV validation
    if (args->operation == MODE_ENCRYPT && args->iv_provided) {
        fprintf(stderr, "Warning: IV provided during encryption will be ignored (using random IV)\n");
        free(args->iv);
        args->iv = NULL;
        args->iv_provided = 0;
    }
    
    if (args->operation == MODE_DECRYPT && args->mode != CIPHER_MODE_ECB && !args->iv_provided) {
        fprintf(stderr, "Warning: No IV provided for decryption, will read from file\n");
    }
    
    if (args->iv_provided && args->iv_len != 16) {
        fprintf(stderr, "Error: IV must be 16 bytes\n");
        return 0;
    }
    
    if (args->output_file == NULL) {
        // Generate default output filename
        const char* extension = (args->operation == MODE_ENCRYPT) ? ".enc" : ".dec";
        size_t len = strlen(args->input_file) + strlen(extension) + 1;
        args->output_file = malloc(len);
        if (args->output_file) {
            snprintf(args->output_file, len, "%s%s", args->input_file, extension);
        }
    }
    
    return 1;
}

void free_cli_args(cli_args_t* args) {
    if (args->algorithm) free(args->algorithm);
    if (args->key) free(args->key);
    if (args->input_file) free(args->input_file);
    if (args->output_file) free(args->output_file);
    if (args->iv) free(args->iv);
}
--- src/crypto.c ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include "crypto.h"
#include "common.h"

// Keep existing ECB functions but update them to use new helper functions
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        aes_encrypt_block(padded_data + i, output + i, key);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for ECB decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        aes_decrypt_block(input + i, output + i, key);
    }
    
    if (!pkcs7_unpad(&output, &input_len)) {
        fprintf(stderr, "Error: PKCS#7 unpadding failed in ECB mode\n");
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}
--- src/file_io.c ---
#include <stdio.h>
#include <stdlib.h>
#include "file_io.h"

unsigned char* read_file(const char* filename, size_t* file_size) {
    FILE* file = fopen(filename, "rb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", filename);
        return NULL;
    }
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    if (size <= 0) {
        fprintf(stderr, "Error: Input file is empty or invalid\n");
        fclose(file);
        return NULL;
    }
    
    unsigned char* buffer = malloc(size);
    if (buffer == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        fclose(file);
        return NULL;
    }
    
    size_t bytes_read = fread(buffer, 1, size, file);
    fclose(file);
    
    if (bytes_read != (size_t)size) {
        fprintf(stderr, "Error: Failed to read entire file\n");
        free(buffer);
        return NULL;
    }
    
    *file_size = bytes_read;
    return buffer;
}

int write_file(const char* filename, const unsigned char* data, size_t data_size) {
    FILE* file = fopen(filename, "wb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", filename);
        return 0;
    }
    
    size_t bytes_written = fwrite(data, 1, data_size, file);
    fclose(file);
    
    if (bytes_written != data_size) {
        fprintf(stderr, "Error: Failed to write entire file\n");
        return 0;
    }
    
    return 1;
}
--- src/main.c ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cli_parser.h"
#include "file_io.h"
#include "crypto.h"
#include "common.h"
#include "types.h"

int main(int argc, char* argv[]) {
    cli_args_t args;
    
    if (!parse_arguments(argc, argv, &args)) {
        print_usage(argv[0]);
        free_cli_args(&args);
        return 1;
    }
    
    // Read input file
    size_t input_size;
    unsigned char* input_data = read_file(args.input_file, &input_size);
    if (input_data == NULL) {
        free_cli_args(&args);
        return 1;
    }
    
    // Handle IV based on operation and mode
    unsigned char iv[16];
    const unsigned char* iv_ptr = NULL;
    size_t data_start = 0;
    size_t data_size = input_size;
    
    if (args.operation == MODE_ENCRYPT) {
        // Generate random IV for modes that need it
        if (args.mode != CIPHER_MODE_ECB) {
            generate_random_iv(iv, 16);
            iv_ptr = iv;
        }
    } else { // DECRYPT
        if (args.mode != CIPHER_MODE_ECB) {
            if (args.iv_provided) {
                // Use provided IV
                iv_ptr = args.iv;
            } else {
                // Read IV from file (first 16 bytes)
                if (input_size < 16) {
                    fprintf(stderr, "Error: Input file too short to contain IV\n");
                    free(input_data);
                    free_cli_args(&args);
                    return 1;
                }
                iv_ptr = input_data;
                data_start = 16;
                data_size = input_size - 16;
            }
        }
    }
    
    // Process data
    size_t output_size;
    unsigned char* output_data = NULL;
    unsigned char* final_output = NULL;
    size_t final_size = 0;
    
    switch (args.mode) {
        case CIPHER_MODE_ECB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ecb_encrypt(input_data + data_start, data_size, args.key, &output_size);
            } else {
                output_data = aes_ecb_decrypt(input_data + data_start, data_size, args.key, &output_size);
            }
            break;
        case CIPHER_MODE_CBC:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_cbc_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_cbc_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CFB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_cfb_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_cfb_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_OFB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ofb_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_ofb_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CTR:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ctr_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_ctr_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        default:
            fprintf(stderr, "Error: Unsupported mode\n");
            free(input_data);
            free_cli_args(&args);
            return 1;
    }
    
    free(input_data);
    
    if (output_data == NULL) {
        fprintf(stderr, "Error: Cryptographic operation failed\n");
        free_cli_args(&args);
        return 1;
    }
    
    // Prepare final output (with IV for encryption)
    if (args.operation == MODE_ENCRYPT && args.mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        final_size = 16 + output_size;
        final_output = malloc(final_size);
        if (final_output) {
            memcpy(final_output, iv_ptr, 16);
            memcpy(final_output + 16, output_data, output_size);
        }
        free(output_data);
    } else {
        final_output = output_data;
        final_size = output_size;
    }
    
    if (final_output == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        free_cli_args(&args);
        return 1;
    }
    
    // Write output file
    if (!write_file(args.output_file, final_output, final_size)) {
        free(final_output);
        free_cli_args(&args);
        return 1;
    }
    
    printf("Success: %s -> %s\n", args.input_file, args.output_file);
    
    // Print IV info for encryption
    if (args.operation == MODE_ENCRYPT && args.mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        printf("Generated IV: ");
        for (int i = 0; i < 16; i++) {
            printf("%02x", iv_ptr[i]);
        }
        printf("\n");
    }
    
    free(final_output);
    free_cli_args(&args);
    return 0;
}
--- src/modes.c ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include "crypto.h"
#include "common.h"
#include "types.h"

// Utility functions
int requires_padding(cipher_mode_t mode) {
    return (mode == CIPHER_MODE_ECB || mode == CIPHER_MODE_CBC);
}

void generate_random_iv(unsigned char* iv, size_t len) {
    if (RAND_bytes(iv, len) != 1) {
        fprintf(stderr, "Error: Failed to generate cryptographically secure IV\n");
        exit(1);
    }
}

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t padding_len = AES_BLOCK_SIZE - (*data_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = *data_len + padding_len;
    unsigned char* new_data = realloc(*data, new_len);
    if (new_data == NULL) return;
    
    for (size_t i = *data_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte\n");
        return 0;
    }
    
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Padding validation failed\n");
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}

// AES block encryption/decryption helper
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_EncryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_DecryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

// CBC Mode
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            block[j] = padded_data[i + j] ^ prev_block[j];
        }
        
        // Encrypt the block
        aes_encrypt_block(block, output + i, key);
        memcpy(prev_block, output + i, AES_BLOCK_SIZE);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for CBC decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Decrypt the block
        aes_decrypt_block(input + i, block, key);
        
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            output[i + j] = block[j] ^ prev_block[j];
        }
        
        memcpy(prev_block, input + i, AES_BLOCK_SIZE);
    }
    
    // Remove padding
    if (!pkcs7_unpad(&output, &input_len)) {
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}

// CFB Mode - CFB-128 implementation (fixed)
unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with encrypted block to get ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (for CFB-128)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, output + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, output + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR ciphertext with encrypted block to get plaintext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (not plaintext)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, input + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, input + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

// OFB Mode
unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting feedback register
        aes_encrypt_block(feedback, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Update feedback register with keystream (not ciphertext)
        memcpy(feedback, keystream, AES_BLOCK_SIZE);
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // OFB decryption is identical to encryption
    return aes_ofb_encrypt(input, input_len, key, iv, output_len);
}

// CTR Mode
unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char counter[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(counter, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting counter
        aes_encrypt_block(counter, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Increment counter (big-endian)
        for (int j = AES_BLOCK_SIZE - 1; j >= 0; j--) {
            if (++counter[j] != 0) break;
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // CTR decryption is identical to encryption
    return aes_ctr_encrypt(input, input_len, key, iv, output_len);
}
--- src/modes/ecb.c ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../../include/modes/ecb.h"

#define AES_BLOCK_SIZE 16

void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t original_len = *data_len;
    size_t padding_len = AES_BLOCK_SIZE - (original_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = original_len + padding_len;
    unsigned char* new_data = malloc(new_len);
    if (new_data == NULL) {
        fprintf(stderr, "Error: Memory allocation failed for padding\n");
        return;
    }
    
    // Copy original data
    if (original_len > 0 && *data != NULL) {
        memcpy(new_data, *data, original_len);
    }
    
    // Add padding
    for (size_t i = original_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    // Free old data and update pointers
    if (*data != NULL) {
        free(*data);
    }
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte: %d\n", padding_byte);
        return 0;
    }
    
    // Check if padding length is valid
    if (padding_byte > *data_len) {
        fprintf(stderr, "Error: Padding length exceeds data length\n");
        return 0;
    }
    
    // Verify all padding bytes
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Invalid padding bytes at position %zu\n", i);
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}
=== HEADER FILES (.h) ===

--- include/cli_parser.h ---
#ifndef CLI_PARSER_H
#define CLI_PARSER_H

typedef enum {
    MODE_ENCRYPT,
    MODE_DECRYPT,
    MODE_UNKNOWN
} operation_mode_t;

typedef struct {
    operation_mode_t mode;
    char* algorithm;
    char* mode_str;
    unsigned char* key;
    size_t key_len;
    char* input_file;
    char* output_file;
} cli_args_t;

int parse_arguments(int argc, char* argv[], cli_args_t* args);
void free_cli_args(cli_args_t* args);
void print_usage(const char* program_name);
int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len);

#endif
--- include/crypto.h ---
#ifndef CRYPTO_H
#define CRYPTO_H

#include <stdlib.h>

unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);
unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);

#endif
--- include/file_io.h ---
#ifndef FILE_IO_H
#define FILE_IO_H

#include <stdlib.h>

unsigned char* read_file(const char* filename, size_t* file_size);
int write_file(const char* filename, const unsigned char* data, size_t data_size);

#endif
--- include/modes/ecb.h ---
#ifndef ECB_H
#define ECB_H

#include <stdlib.h>

void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

#endif
--- src/cli_parser.h ---
#ifndef CLI_PARSER_H
#define CLI_PARSER_H

#include <stdlib.h>
#include "types.h"

typedef struct {
    operation_mode_t operation;
    cipher_mode_t mode;
    char* algorithm;
    unsigned char* key;
    size_t key_len;
    char* input_file;
    char* output_file;
    unsigned char* iv;
    size_t iv_len;
    int iv_provided;
} cli_args_t;

int parse_arguments(int argc, char* argv[], cli_args_t* args);
void free_cli_args(cli_args_t* args);
void print_usage(const char* program_name);
cipher_mode_t parse_cipher_mode(const char* mode_str);

#endif
--- src/common.h ---
#ifndef COMMON_H
#define COMMON_H

#include <stdlib.h>
#include "types.h"

#define AES_BLOCK_SIZE 16

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

// AES block operations
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);
void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);

#endif
--- src/crypto.h ---
#ifndef CRYPTO_H
#define CRYPTO_H

#include <stdlib.h>
#include "types.h"

// Existing ECB functions
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);
unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);

// New mode functions
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

// Utility functions
int requires_padding(cipher_mode_t mode);
void generate_random_iv(unsigned char* iv, size_t len);

#endif
--- src/file_io.h ---
#ifndef FILE_IO_H
#define FILE_IO_H

#include <stdlib.h>

unsigned char* read_file(const char* filename, size_t* file_size);
int write_file(const char* filename, const unsigned char* data, size_t data_size);

#endif
--- src/types.h ---
#ifndef TYPES_H
#define TYPES_H

typedef enum {
    MODE_ENCRYPT,
    MODE_DECRYPT,
    MODE_UNKNOWN
} operation_mode_t;

typedef enum {
    CIPHER_MODE_ECB,
    CIPHER_MODE_CBC,
    CIPHER_MODE_CFB,
    CIPHER_MODE_OFB,
    CIPHER_MODE_CTR,
    CIPHER_MODE_UNKNOWN
} cipher_mode_t;

#endif
=== TEST SCRIPTS ===

--- tests/debug_test.sh ---
#!/bin/bash

# Debug script to test individual modes

set -e

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY="@00112233445566778899aabbccddeeff"
IV="@aabbccddeeff00112233445566778899"

mkdir -p "$TEST_DIR"

# Create test file
echo "Hello, CryptoCore! This is a test." > "$TEST_DIR/debug_test.txt"

test_single_mode() {
    local mode=$1
    local input_file="$TEST_DIR/debug_test.txt"
    local encrypted_file="$TEST_DIR/debug_$mode.enc"
    local decrypted_file="$TEST_DIR/debug_$mode.dec"
    
    echo "=== Testing $mode mode ==="
    
    # Clean up
    rm -f "$encrypted_file" "$decrypted_file"
    
    # Encrypt
    echo "Encrypting..."
    if "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file"; then
        echo "âœ“ Encryption successful"
        echo "Encrypted file size: $(stat -c%s "$encrypted_file") bytes"
        
        # Show first 32 bytes of encrypted file in hex
        echo "First 32 bytes (hex):"
        xxd -l 32 "$encrypted_file"
    else
        echo "âœ— Encryption failed"
        return 1
    fi
    
    # Decrypt
    echo "Decrypting..."
    if [ "$mode" = "ecb" ]; then
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "âœ“ Decryption successful"
        else
            echo "âœ— Decryption failed"
            return 1
        fi
    else
        # Try both with and without IV
        echo "Trying decryption without IV (read from file)..."
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "âœ“ Decryption successful (IV from file)"
        else
            echo "Trying decryption with explicit IV..."
            if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$encrypted_file" -output "$decrypted_file"; then
                echo "âœ“ Decryption successful (with explicit IV)"
            else
                echo "âœ— All decryption attempts failed"
                return 1
            fi
        fi
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null; then
        echo "âœ“ Round-trip successful - files are identical"
        return 0
    else
        echo "âœ— Round-trip failed - files differ"
        echo "Original: $(stat -c%s "$input_file") bytes"
        echo "Decrypted: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test specific mode or all
if [ $# -eq 1 ]; then
    test_single_mode "$1"
else
    echo "Usage: $0 [mode]"
    echo "Modes: ecb, cbc, cfb, ofb, ctr"
    echo ""
    echo "Available tests:"
    echo "  ./test_roundtrip.sh    - Basic round-trip tests"
    echo "  ./test_interoperability.sh - OpenSSL compatibility tests"
    echo "  ./debug_test.sh [mode] - Debug individual mode"
fi
--- tests/fixed_interop_test.sh ---
#!/bin/bash

# Fixed Interoperability Test Script

echo "=== Fixed CryptoCore OpenSSL Interoperability Test ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    echo "Please build the project first using 'make' in the root directory"
    exit 1
fi

# Create test directory
mkdir -p test_files
cd test_files

# Create test file with specific size (multiple of 16 bytes for no-padding tests)
echo -n "0123456789ABCDEF" > "test_16.txt"  # 16 bytes
echo "This is a test file for CryptoCore interoperability testing." > "test_text.txt"

echo "=== Testing Round-trip First ==="

# Test round-trip for all modes
for mode in ecb cbc cfb ofb ctr; do
    echo "Testing $mode round-trip..."
    "$BIN" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "test_16.txt" -output "test_${mode}.enc"
    "$BIN" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "test_${mode}.enc" -output "test_${mode}.dec"
    
    if diff "test_16.txt" "test_${mode}.dec" > /dev/null; then
        echo "âœ“ $mode round-trip OK"
    else
        echo "âœ— $mode round-trip FAILED"
    fi
done

echo ""
echo "=== Testing OpenSSL Interoperability ==="

# Test 1: CryptoCore -> OpenSSL (ECB)
echo "1. CryptoCore -> OpenSSL (ECB)"
"$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "test_16.txt" -output "cc_ecb.enc"

# OpenSSL decryption
if openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "cc_ecb.enc" -out "os_ecb.dec" -nopad 2>/dev/null; then
    if diff "test_16.txt" "os_ecb.dec" > /dev/null; then
        echo "   âœ“ ECB: CryptoCore -> OpenSSL OK"
    else
        echo "   âœ— ECB: CryptoCore -> OpenSSL FAILED - files differ"
        echo "   Original size: $(stat -c%s test_16.txt), Decrypted: $(stat -c%s os_ecb.dec)"
    fi
else
    echo "   âœ— ECB: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
fi

# Test 2: OpenSSL -> CryptoCore (ECB)  
echo "2. OpenSSL -> CryptoCore (ECB)"
if openssl enc -aes-128-ecb -K "$KEY_HEX" -in "test_16.txt" -out "os_ecb.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "os_ecb.enc" -output "cc_ecb.dec"

    if diff "test_16.txt" "cc_ecb.dec" > /dev/null; then
        echo "   âœ“ ECB: OpenSSL -> CryptoCore OK"
    else
        echo "   âœ— ECB: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   âœ— ECB: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test 3: CryptoCore -> OpenSSL (CBC)
echo "3. CryptoCore -> OpenSSL (CBC)"
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_16.txt" -output "cc_cbc.enc"

# Extract IV and ciphertext
dd if="cc_cbc.enc" of="iv.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc.enc" of="ciphertext.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv.bin" ] && [ -f "ciphertext.bin" ]; then
    IV_FROM_FILE=$(xxd -p "iv.bin" | tr -d '\n')

    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "ciphertext.bin" -out "os_cbc.dec" -nopad 2>/dev/null; then
        if diff "test_16.txt" "os_cbc.dec" > /dev/null; then
            echo "   âœ“ CBC: CryptoCore -> OpenSSL OK"
        else
            echo "   âœ— CBC: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   âœ— CBC: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   âœ— CBC: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Test 4: OpenSSL -> CryptoCore (CBC)
echo "4. OpenSSL -> CryptoCore (CBC)"
if openssl enc -aes-128-cbc -K "$KEY_HEX" -iv "00000000000000000000000000000000" -in "test_16.txt" -out "os_cbc.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -iv "@00000000000000000000000000000000" -input "os_cbc.enc" -output "cc_cbc.dec"

    if diff "test_16.txt" "cc_cbc.dec" > /dev/null; then
        echo "   âœ“ CBC: OpenSSL -> CryptoCore OK"
    else
        echo "   âœ— CBC: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   âœ— CBC: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test with text files (with padding)
echo ""
echo "=== Testing with Padding ==="

# CryptoCore CBC with text (auto padding)
echo "Testing CBC with padding..."
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_text.txt" -output "cc_cbc_pad.enc"

# Extract IV and ciphertext
dd if="cc_cbc_pad.enc" of="iv_pad.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc_pad.enc" of="ciphertext_pad.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv_pad.bin" ] && [ -f "ciphertext_pad.bin" ]; then
    IV_PAD=$(xxd -p "iv_pad.bin" | tr -d '\n')

    # OpenSSL decryption with padding (no -nopad flag)
    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_PAD" -in "ciphertext_pad.bin" -out "os_cbc_pad.dec" 2>/dev/null; then
        if diff "test_text.txt" "os_cbc_pad.dec" > /dev/null; then
            echo "   âœ“ CBC with padding: CryptoCore -> OpenSSL OK"
        else
            echo "   âœ— CBC with padding: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   âœ— CBC with padding: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   âœ— CBC with padding: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Cleanup
cd ..
rm -rf test_files

echo ""
echo "=== Interoperability Test Complete ==="
--- tests/openssl_safe_test.sh ---
#!/bin/bash

echo "=== OPENSSL SAFE TEST (Ð±ÐµÐ· ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ñ„Ð°Ð¹Ð»Ð¾Ð²) ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"

# Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ OpenSSL Ñ‚ÐµÑÑ‚Ð¾Ð²
mkdir -p openssl_temp
cd openssl_temp

# ÐšÐ¾Ð¿Ð¸Ñ€ÑƒÐµÐ¼ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»
cp ../test_files/test_16_bytes.txt .

echo "Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÑŽ ECB Ñ OpenSSL..."
# Ð¨Ð¸Ñ„Ñ€ÑƒÐµÐ¼ CryptoCore
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_16_bytes.txt -output cc_ecb.enc

# ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ OpenSSL
if openssl enc -aes-128-ecb -d -K $KEY_HEX -in cc_ecb.enc -out openssl_ecb.dec -nopad 2>/dev/null; then
    if diff test_16_bytes.txt openssl_ecb.dec > /dev/null; then
        echo "âœ… ECB: CryptoCore -> OpenSSL Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢"
    else
        echo "âŒ ECB: CryptoCore -> OpenSSL ÐÐ• Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢ - Ñ„Ð°Ð¹Ð»Ñ‹ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð°ÑŽÑ‚ÑÑ"
        echo "ÐžÑ€Ð¸Ð³Ð¸Ð½Ð°Ð»: $(xxd -l 16 test_16_bytes.txt)"
        echo "OpenSSL:  $(xxd -l 16 openssl_ecb.dec)"
    fi
else
    echo "âŒ ECB: OpenSSL Ð½Ðµ ÑÐ¼Ð¾Ð³ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"
fi

echo
echo "Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÑŽ CBC Ñ OpenSSL..."
# Ð¨Ð¸Ñ„Ñ€ÑƒÐµÐ¼ CryptoCore
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_16_bytes.txt -output cc_cbc.enc

# Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ IV
dd if=cc_cbc.enc of=iv.bin bs=16 count=1 status=none 2>/dev/null
dd if=cc_cbc.enc of=ciphertext.bin bs=16 skip=1 status=none 2>/dev/null

if [ -f iv.bin ] && [ -f ciphertext.bin ]; then
    IV_HEX=$(xxd -p iv.bin | tr -d '\n')
    
    if openssl enc -aes-128-cbc -d -K $KEY_HEX -iv $IV_HEX -in ciphertext.bin -out openssl_cbc.dec -nopad 2>/dev/null; then
        if diff test_16_bytes.txt openssl_cbc.dec > /dev/null; then
            echo "âœ… CBC: CryptoCore -> OpenSSL Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢"
        else
            echo "âŒ CBC: CryptoCore -> OpenSSL ÐÐ• Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢ - Ñ„Ð°Ð¹Ð»Ñ‹ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð°ÑŽÑ‚ÑÑ"
        fi
    else
        echo "âŒ CBC: OpenSSL Ð½Ðµ ÑÐ¼Ð¾Ð³ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"
    fi
else
    echo "âŒ CBC: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ IV Ð¸Ð»Ð¸ ÑˆÐ¸Ñ„Ñ€Ñ‚ÐµÐºÑÑ‚"
fi

# Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ÑÑ Ð¸ Ð¾Ñ‡Ð¸Ñ‰Ð°ÐµÐ¼
cd ..
rm -rf openssl_temp

echo "=== OPENSSL Ð¢Ð•Ð¡Ð¢ Ð—ÐÐ’Ð•Ð Ð¨Ð•Ð ==="

--- tests/padding_test.sh ---
#!/bin/bash

# Padding Test Script

echo "=== Padding Test ==="

BIN="../bin/cryptocore"
KEY="@00112233445566778899aabbccddeeff"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    exit 1
fi

mkdir -p padding_test
cd padding_test

# Create test files of different sizes
echo -n "15_bytes_____" > "15.txt"  # 15 bytes
echo -n "16_bytes_______" > "16.txt"  # 16 bytes  
echo -n "17_bytes________" > "17.txt"  # 17 bytes
echo -n "31_bytes_______________________" > "31.txt"  # 31 bytes
echo -n "32_bytes______________________________" > "32.txt"  # 32 bytes

echo "Testing padding for different file sizes..."

for file in 15.txt 16.txt 17.txt 31.txt 32.txt; do
    size=$(stat -c%s "$file")
    echo "File: $file ($size bytes)"
    
    # Test ECB (requires padding)
    if "$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.ecb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "${file%.txt}.ecb.enc" -output "${file%.txt}.ecb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.ecb.dec" > /dev/null; then
            echo "  âœ“ ECB padding OK"
        else
            echo "  âœ— ECB padding FAILED"
        fi
    else
        echo "  âœ— ECB padding FAILED - encryption/decryption error"
    fi
    
    # Test CBC (requires padding)
    if "$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cbc.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -input "${file%.txt}.cbc.enc" -output "${file%.txt}.cbc.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cbc.dec" > /dev/null; then
            echo "  âœ“ CBC padding OK"
        else
            echo "  âœ— CBC padding FAILED"
        fi
    else
        echo "  âœ— CBC padding FAILED - encryption/decryption error"
    fi
    
    # Test CFB (no padding)
    if "$BIN" -algorithm aes -mode cfb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cfb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cfb -decrypt -key "$KEY" -input "${file%.txt}.cfb.enc" -output "${file%.txt}.cfb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cfb.dec" > /dev/null; then
            echo "  âœ“ CFB no-padding OK"
        else
            echo "  âœ— CFB no-padding FAILED"
        fi
    else
        echo "  âœ— CFB no-padding FAILED - encryption/decryption error"
    fi
    
    echo ""
done

cd ..
rm -rf padding_test

echo "=== Padding Test Complete ==="
--- tests/safe_test.sh ---
#!/bin/bash

echo "=== SAFE CRYPTOCORE TESTS (Ð±ÐµÐ· ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ñ„Ð°Ð¹Ð»Ð¾Ð²) ==="

BIN="../bin/cryptocore"
KEY="@00112233445566778899aabbccddeeff"

# ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‡Ñ‚Ð¾ Ð±Ð¸Ð½Ð°Ñ€Ð½Ð¸Ðº ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
if [ ! -f "$BIN" ]; then
    echo "ÐžÐ¨Ð˜Ð‘ÐšÐ: cryptocore Ð±Ð¸Ð½Ð°Ñ€Ð½Ð¸Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½!"
    exit 1
fi

echo "âœ“ Ð‘Ð¸Ð½Ð°Ñ€Ð½Ð¸Ðº Ð½Ð°Ð¹Ð´ÐµÐ½"
echo "âœ“ Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹"
echo

# Ð¢ÐµÑÑ‚ 1: Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ñ€ÐµÐ¶Ð¸Ð¼Ñ‹
echo "--- Ð¢Ð•Ð¡Ð¢ 1: Ð‘ÐÐ—ÐžÐ’Ð«Ð• Ð Ð•Ð–Ð˜ÐœÐ« ---"
for mode in ecb cbc cfb ofb ctr; do
    echo -n "Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÑŽ $mode... "
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input test_files/test1.txt -output test_${mode}.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input test_${mode}.enc -output test_${mode}.dec
    
    if diff test_files/test1.txt test_${mode}.dec > /dev/null 2>&1; then
        echo "âœ… Ð£Ð¡ÐŸÐ•Ð¥"
    else
        echo "âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ"
    fi
done

echo

# Ð¢ÐµÑÑ‚ 2: Ð Ð°Ð·Ð½Ñ‹Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€Ñ‹ Ñ„Ð°Ð¹Ð»Ð¾Ð²
echo "--- Ð¢Ð•Ð¡Ð¢ 2: Ð ÐÐ—ÐÐ«Ð• Ð ÐÐ—ÐœÐ•Ð Ð« Ð¤ÐÐ™Ð›ÐžÐ’ ---"
echo -n "16 Ð±Ð°Ð¹Ñ‚ (Ð±ÐµÐ· padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_files/test_16_bytes.txt -output test_16_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input test_16_enc.enc -output test_16_dec.txt
diff test_files/test_16_bytes.txt test_16_dec.txt > /dev/null 2>&1 && echo "âœ… Ð£Ð¡ÐŸÐ•Ð¥" || echo "âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ"

echo -n "15 Ð±Ð°Ð¹Ñ‚ (Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_files/test_15_bytes.txt -output test_15_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input test_15_enc.enc -output test_15_dec.txt
diff test_files/test_15_bytes.txt test_15_dec.txt > /dev/null 2>&1 && echo "âœ… Ð£Ð¡ÐŸÐ•Ð¥" || echo "âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ"

echo

# Ð¢ÐµÑÑ‚ 3: Ð‘Ð¸Ð½Ð°Ñ€Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹
echo "--- Ð¢Ð•Ð¡Ð¢ 3: Ð‘Ð˜ÐÐÐ ÐÐ«Ð• Ð¤ÐÐ™Ð›Ð« ---"
echo -n "Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ... "
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_files/random_binary.bin -output test_bin_enc.enc
$BIN -algorithm aes -mode cbc -decrypt -key $KEY -input test_bin_enc.enc -output test_bin_dec.bin
diff test_files/random_binary.bin test_bin_dec.bin > /dev/null 2>&1 && echo "âœ… Ð£Ð¡ÐŸÐ•Ð¥" || echo "âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ"

echo

# Ð¢ÐµÑÑ‚ 4: IV Ñ€Ð°Ð±Ð¾Ñ‚Ð°
echo "--- Ð¢Ð•Ð¡Ð¢ 4: ÐŸÐ ÐžÐ’Ð•Ð ÐšÐ IV ---"
echo "Ð¨Ð¸Ñ„Ñ€ÑƒÐµÐ¼ CBC Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ IV..."
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_files/test1.txt -output test_cbc_iv.enc
echo "Ð Ð°Ð·Ð¼ÐµÑ€ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð°: $(stat -c%s test_cbc_iv.enc) Ð±Ð°Ð¹Ñ‚"
echo "ÐŸÐµÑ€Ð²Ñ‹Ðµ 32 Ð±Ð°Ð¹Ñ‚Ð° (hex):"
xxd -l 32 test_cbc_iv.enc

echo

# ÐžÑ‡Ð¸Ñ‰Ð°ÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ñ‚ÐµÑÑ‚Ð¾Ð² (Ð½Ðµ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹)
echo "ÐžÑ‡Ð¸Ñ‰Ð°ÑŽ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ñ‚ÐµÑÑ‚Ð¾Ð²..."
rm -f test_*.enc test_*.dec test_*.bin

echo "=== Ð¢Ð•Ð¡Ð¢Ð˜Ð ÐžÐ’ÐÐÐ˜Ð• Ð—ÐÐ’Ð•Ð Ð¨Ð•ÐÐž ==="
echo "âœ“ ÐžÑ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹ Ð² test_files/"
echo "âœ“ Ð’ÑÐµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ ÑƒÐ´Ð°Ð»ÐµÐ½Ñ‹"

--- tests/test_interoperability.sh ---
#!/bin/bash

# CryptoCore OpenSSL Interoperability Test Script
# Tests compatibility between CryptoCore and OpenSSL

set -e

echo "=== CryptoCore OpenSSL Interoperability Tests ==="
echo

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"
IV_HEX="aabbccddeeff00112233445566778899"
IV="@$IV_HEX"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Check if OpenSSL is available
if ! command -v openssl &> /dev/null; then
    echo -e "${RED}Error: openssl command not found${NC}"
    echo "Install with: sudo apt-get install openssl"
    exit 1
fi

# Check if xxd is available
if ! command -v xxd &> /dev/null; then
    echo -e "${RED}Error: xxd command not found${NC}"
    echo "Install with: sudo apt-get install xxd"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test file
echo "This is a test file for interoperability testing." > "$TEST_DIR/interop_test.txt"
TEST_FILE_SIZE=$(stat -c%s "$TEST_DIR/interop_test.txt")
echo "Test file size: $TEST_FILE_SIZE bytes"

# Test function for CryptoCore -> OpenSSL
test_cryptocore_to_openssl() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local cryptocore_encrypted="$TEST_DIR/interop_${mode}_cryptocore.enc"
    local iv_file="$TEST_DIR/iv.bin"
    local ciphertext_only="$TEST_DIR/ciphertext_only.bin"
    local openssl_decrypted="$TEST_DIR/decrypted_openssl.txt"
    
    echo "Testing CryptoCore -> OpenSSL for $mode mode..."
    
    # Clean up any existing files
    rm -f "$cryptocore_encrypted" "$iv_file" "$ciphertext_only" "$openssl_decrypted"
    
    # Encrypt with CryptoCore
    echo "Encrypting with CryptoCore..."
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$cryptocore_encrypted" 2>/dev/null; then
        echo -e "${RED}FAIL: CryptoCore encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$cryptocore_encrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore encrypted file not created for $mode${NC}"
        return 1
    fi
    
    local encrypted_size=$(stat -c%s "$cryptocore_encrypted")
    echo "CryptoCore encrypted file size: $encrypted_size bytes"
    
    if [ "$mode" != "ecb" ]; then
        # Extract IV and ciphertext for modes that use IV
        echo "Extracting IV and ciphertext..."
        dd if="$cryptocore_encrypted" of="$iv_file" bs=16 count=1 status=none
        dd if="$cryptocore_encrypted" of="$ciphertext_only" bs=16 skip=1 status=none
        
        # Check if extraction worked
        if [ ! -f "$iv_file" ] || [ ! -f "$ciphertext_only" ]; then
            echo -e "${RED}FAIL: Failed to extract IV or ciphertext for $mode${NC}"
            return 1
        fi
        
        # Get IV as hex string
        IV_FROM_FILE=$(xxd -p "$iv_file" | tr -d '\n')
        echo "IV from file: $IV_FROM_FILE"
        
        # Decrypt with OpenSSL
        echo "Decrypting with OpenSSL..."
        if ! openssl enc -aes-128-$openssl_mode -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    else
        # ECB mode - no IV
        cp "$cryptocore_encrypted" "$ciphertext_only"
        echo "Decrypting ECB with OpenSSL..."
        if ! openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$openssl_decrypted" ]; then
        echo -e "${RED}FAIL: OpenSSL decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$openssl_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: CryptoCore -> OpenSSL successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: CryptoCore -> OpenSSL failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$openssl_decrypted") bytes"
        return 1
    fi
}

# Test function for OpenSSL -> CryptoCore
test_openssl_to_cryptocore() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local openssl_encrypted="$TEST_DIR/interop_${mode}_openssl.enc"
    local cryptocore_decrypted="$TEST_DIR/decrypted_cryptocore.txt"
    
    echo "Testing OpenSSL -> CryptoCore for $mode mode..."
    
    # Clean up any existing files
    rm -f "$openssl_encrypted" "$cryptocore_decrypted"
    
    # Encrypt with OpenSSL
    echo "Encrypting with OpenSSL..."
    if [ "$mode" != "ecb" ]; then
        if ! openssl enc -aes-128-$openssl_mode -K "$KEY_HEX" -iv "$IV_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        # Check if encrypted file was created
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        # Decrypt with CryptoCore using provided IV
        echo "Decrypting with CryptoCore..."
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    else
        # ECB mode - no IV
        if ! openssl enc -aes-128-ecb -K "$KEY_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$cryptocore_decrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$cryptocore_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: OpenSSL -> CryptoCore successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: OpenSSL -> CryptoCore failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$cryptocore_decrypted") bytes"
        return 1
    fi
}

# Clean up before starting
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
openssl_modes=("ecb" "cbc" "cfb" "ofb" "ctr")

passed=0
total=0

echo "=== CryptoCore -> OpenSSL Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_cryptocore_to_openssl "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

echo "=== OpenSSL -> CryptoCore Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_openssl_to_cryptocore "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

# Final cleanup
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin "$TEST_DIR"/interop_test.txt

echo "=== Interoperability Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All interoperability tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some interoperability tests failed!${NC}"
    exit 1
fi
--- tests/test_roundtrip.sh ---
#!/bin/bash

# CryptoCore Round-trip Test Script
# Tests encryption and decryption for all modes

set -e

echo "=== CryptoCore Round-trip Tests ==="
echo

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY="@00112233445566778899aabbccddeeff"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test files
echo "Creating test files..."
echo "This is a test file for CryptoCore." > "$TEST_DIR/test1.txt"
echo "Another test file with different content." > "$TEST_DIR/test2.txt"

# Generate a binary test file
head -c 100 /dev/urandom > "$TEST_DIR/test3.bin"

# Test function
test_mode() {
    local mode=$1
    local input_file="$TEST_DIR/test1.txt"
    local encrypted_file="$TEST_DIR/test1.$mode.enc"
    local decrypted_file="$TEST_DIR/test1.$mode.dec"
    
    echo "Testing $mode mode..."
    
    # Encrypt
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file" 2>/dev/null; then
        echo -e "${RED}FAIL: Encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$encrypted_file" ]; then
        echo -e "${RED}FAIL: Encrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Decrypt
    if [ "$mode" = "ecb" ]; then
        # ECB mode - no IV handling
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    else
        # For other modes, IV is read from file automatically
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$decrypted_file" ]; then
        echo -e "${RED}FAIL: Decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: $mode round-trip successful${NC}"
        # Clean up test files for this mode
        rm -f "$encrypted_file" "$decrypted_file"
        return 0
    else
        echo -e "${RED}FAIL: $mode round-trip failed - files differ${NC}"
        echo "Input file size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted file size: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
passed=0
total=0

echo "Starting round-trip tests..."
echo

for mode in "${modes[@]}"; do
    if test_mode "$mode"; then
        ((passed++))
    else
        # Debug info for failed test
        echo "Debug info for $mode:"
        ls -la "$TEST_DIR"/test1.$mode.* 2>/dev/null || echo "No test files found"
    fi
    ((total++))
    echo
done

# Clean up original test files
rm -f "$TEST_DIR"/test1.txt "$TEST_DIR"/test2.txt "$TEST_DIR"/test3.bin

echo "=== Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some tests failed!${NC}"
    exit 1
fi