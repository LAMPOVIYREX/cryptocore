]633;E;echo "=== –ü–û–õ–ù–´–ô –î–ê–ú–ü –ü–†–û–ï–ö–¢–ê CRYPTOCORE ===";32fd46f1-78e7-43c1-a036-cf16797196f1]633;C=== –ü–û–õ–ù–´–ô –î–ê–ú–ü –ü–†–û–ï–ö–¢–ê CRYPTOCORE ===
–°–æ–∑–¥–∞–Ω: –í—Ç 25 –Ω–æ—è 2025 21:21:46 MSK
========================================



====================================================================
–§–ê–ô–õ: ./include/modes/ecb.h
====================================================================
#ifndef ECB_H
#define ECB_H

#include <stdlib.h>

void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

#endif


====================================================================
–§–ê–ô–õ: ./include/file_io.h
====================================================================
#ifndef FILE_IO_H
#define FILE_IO_H

#include <stdlib.h>

unsigned char* read_file(const char* filename, size_t* file_size);
int write_file(const char* filename, const unsigned char* data, size_t data_size);

#endif


====================================================================
–§–ê–ô–õ: ./include/crypto.h
====================================================================
#ifndef CRYPTO_H
#define CRYPTO_H

#include <stdlib.h>

unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);
unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);

#endif


====================================================================
–§–ê–ô–õ: ./include/cli_parser.h
====================================================================
#ifndef CLI_PARSER_H
#define CLI_PARSER_H

typedef enum {
    MODE_ENCRYPT,
    MODE_DECRYPT,
    MODE_UNKNOWN
} operation_mode_t;

typedef struct {
    operation_mode_t mode;
    char* algorithm;
    char* mode_str;
    unsigned char* key;
    size_t key_len;
    char* input_file;
    char* output_file;
} cli_args_t;

int parse_arguments(int argc, char* argv[], cli_args_t* args);
void free_cli_args(cli_args_t* args);
void print_usage(const char* program_name);
int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len);

#endif


====================================================================
–§–ê–ô–õ: ./Makefile
====================================================================
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -O2
LDFLAGS = -lcrypto

SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin

SOURCES = $(wildcard $(SRC_DIR)/*.c)
OBJECTS = $(SOURCES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
TARGET = $(BIN_DIR)/cryptocore

TEST_SRC = tests/test_roundtrip.c
TEST_OBJ = $(OBJ_DIR)/test_roundtrip.o
TEST_TARGET = $(BIN_DIR)/test_roundtrip

CSRPNG_TEST_SRC = tests/test_csprng.c
CSRPNG_TEST_OBJ = $(OBJ_DIR)/test_csprng.o
CSRPNG_TEST_TARGET = $(BIN_DIR)/test_csprng

NIST_TEST_SCRIPT = tests/run_nist_tests.sh

.PHONY: all clean test csprng_test nist_test

all: $(TARGET)

$(TARGET): $(OBJECTS) | $(BIN_DIR)
	$(CC) $(OBJECTS) -o $@ $(LDFLAGS)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# –ü—Ä–∞–≤–∏–ª–æ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
$(OBJ_DIR)/%.o: tests/%.c | $(OBJ_DIR)
	$(CC) $(CFLAGS) -I$(SRC_DIR) -c $< -o $@

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

$(BIN_DIR):
	mkdir -p $(BIN_DIR)

test: $(TEST_TARGET) $(CSRPNG_TEST_TARGET)
	@echo "=== Running Round-trip Tests ==="
	./$(TEST_TARGET)
	@echo ""
	@echo "=== Running CSPRNG Tests ==="
	./$(CSRPNG_TEST_TARGET)

$(TEST_TARGET): $(TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) | $(BIN_DIR)
	$(CC) $(TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) -o $@ $(LDFLAGS)

csprng_test: $(CSRPNG_TEST_TARGET)
	./$(CSRPNG_TEST_TARGET)

$(CSRPNG_TEST_TARGET): $(CSRPNG_TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) | $(BIN_DIR)
	$(CC) $(CSRPNG_TEST_OBJ) $(filter-out $(OBJ_DIR)/main.o, $(OBJECTS)) -o $@ $(LDFLAGS)

nist_test: $(CSRPNG_TEST_TARGET)
	@echo "=== Running NIST Statistical Tests ==="
	@if [ -f "$(NIST_TEST_SCRIPT)" ]; then \
		chmod +x $(NIST_TEST_SCRIPT) && ./$(NIST_TEST_SCRIPT); \
	else \
		echo "Error: NIST test script not found"; \
		echo "Please generate test data manually: ./bin/test_csprng"; \
		echo "Then run NIST STS on nist_test_data.bin"; \
	fi

clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR) nist_test_data.bin

install-dependencies:
	sudo apt-get update
	sudo apt-get install libssl-dev


====================================================================
–§–ê–ô–õ: ./test_dec2.txt
====================================================================
Hello, this is a test file for CryptoCore!



====================================================================
–§–ê–ô–õ: ./plain.txt
====================================================================
dadudu


====================================================================
–§–ê–ô–õ: ./full_code_dump.txt
====================================================================



====================================================================
–§–ê–ô–õ: ./README.md
====================================================================
# CryptoCore

A command-line tool for AES encryption and decryption supporting multiple modes of operation (ECB, CBC, CFB, OFB, CTR).

## Features

- **Algorithms**: AES-128
- **Modes**: ECB, CBC, CFB, OFB, CTR  
- **Padding**: PKCS#7 (for ECB and CBC modes)
- **Key Management**: Automatic secure key generation or hexadecimal input
- **IV Handling**: Automatic generation for encryption, file-based or argument for decryption
- **Security**: Cryptographically secure random number generation using OpenSSL RAND_bytes

## Build Instructions

### Prerequisites

- GCC compiler
- OpenSSL development libraries

### On Ubuntu/Debian:
```bash
sudo apt-get update
sudo apt-get install build-essential libssl-dev

Build:
bash
make
Usage
Encryption with auto-generated key:
bash
./bin/cryptocore -algorithm aes -mode cbc -encrypt -input plain.txt -output cipher.bin
The tool will generate a secure random key and display it:

text
Generated random key: 1a2b3c4d5e6f7890fedcba9876543210
Success: plain.txt -> cipher.bin
Generated IV: aabbccddeeff00112233445566778899
Encryption with specific key:
bash
./bin/cryptocore -algorithm aes -mode cbc -encrypt -key 00112233445566778899aabbccddeeff -input plain.txt -output cipher.bin
Decryption:
bash
./bin/cryptocore -algorithm aes -mode cbc -decrypt -key 00112233445566778899aabbccddeeff -input cipher.bin -output decrypted.txt
Supported Modes:
ecb - Electronic Codebook (no IV)

cbc - Cipher Block Chaining

cfb - Cipher Feedback

ofb - Output Feedback

ctr - Counter

Key and IV Format
Keys: 16-byte hexadecimal strings (32 hex characters)

IVs: 16-byte hexadecimal strings (32 hex characters)

No @ prefix required - use plain hex strings

CSPRNG Security
The tool uses OpenSSL's RAND_bytes() for cryptographically secure random number generation, which:

Uses /dev/urandom on Unix systems

Provides cryptographically strong randomness

Is suitable for cryptographic key generation

NIST Statistical Test Suite
Installing NIST STS
Download from NIST website

Extract and compile:

bash
tar -xzf sts-2.1.2.tar.gz
cd sts-2.1.2
make
Running NIST Tests
Generate test data using CryptoCore's CSPRNG:

bash
make csprng_test
./bin/test_csprng
Run NIST STS on generated data:

bash
cd sts-2.1.2
./assess 1000000
# Follow prompts to specify the test file: ../nist_test_data.bin
View results in ./experiments/AlgorithmTesting/finalAnalysisReport.txt

Expected Results
A properly functioning CSPRNG should pass the majority of NIST tests. Typical results:

Frequency Test: PASS

Block Frequency Test: PASS

Runs Test: PASS

Longest Runs Test: PASS

DFT Test: PASS

Non-overlapping Templates: PASS (most templates)

Overlapping Templates: PASS

Universal Statistical Test: PASS

Linear Complexity Test: PASS

Serial Test: PASS

Approximate Entropy Test: PASS

Cumulative Sums Test: PASS

Random Excursions Test: PASS (most states)

Random Excursions Variant Test: PASS (most states)

A small number of failures is statistically expected, but widespread failures indicate RNG flaws.

Testing
Run all tests:
bash
make test
Run specific test suites:
bash
# Round-trip tests
./tests/test_roundtrip.sh

# OpenSSL interoperability
./tests/test_interoperability.sh

# Key generation tests
./tests/test_key_generation.sh

# CSPRNG statistical tests
./bin/test_csprng
Security Notes
Generated keys are displayed only once - save them securely

The tool warns about potentially weak user-provided keys

IVs are automatically generated using CSPRNG for encryption

For decryption, IVs can be read from file or provided via command line

text

## 4. –°–æ–∑–¥–∞–µ–º —Å–∫—Ä–∏–ø—Ç –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ NIST —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è `tests/run_nist_tests.sh`

```bash
#!/bin/bash

echo "=== NIST Statistical Test Suite Runner ==="

# Check if NIST STS is available
NIST_DIR="../sts-2.1.2"
NIST_BIN="$NIST_DIR/assess"

if [ ! -f "$NIST_BIN" ]; then
    echo "Error: NIST STS not found at $NIST_DIR"
    echo "Please download and compile NIST STS first:"
    echo "1. Download from https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"
    echo "2. Extract to sts-2.1.2 directory in project root"
    echo "3. Run 'make' in the sts-2.1.2 directory"
    exit 1
fi

echo "‚úì NIST STS found"

# Generate test data if not exists
TEST_DATA="nist_test_data.bin"
if [ ! -f "$TEST_DATA" ]; then
    echo "Generating test data..."
    ./bin/test_csprng
fi

if [ ! -f "$TEST_DATA" ]; then
    echo "Error: Failed to generate test data"
    exit 1
fi

echo "‚úì Test data ready: $TEST_DATA ($(stat -c%s "$TEST_DATA") bytes)"

# Run NIST tests
echo "Running NIST Statistical Test Suite..."
cd "$NIST_DIR"

# Create assessment configuration
cat > assess_config.txt << EOF
$TEST_DATA
0
1
1000000
EOF

./assess 1000000 < assess_config.txt

echo ""
echo "=== NIST Tests Complete ==="
echo "Results available in: $NIST_DIR/experiments/AlgorithmTesting/finalAnalysisReport.txt"
echo "Summary of results:"

# Extract and display summary
if [ -f "experiments/AlgorithmTesting/finalAnalysisReport.txt" ]; then
    grep -E "(TEST|passed|failed)" "experiments/AlgorithmTesting/finalAnalysisReport.txt" | head -20
fi


====================================================================
–§–ê–ô–õ: ./src/file_io.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include "file_io.h"

unsigned char* read_file(const char* filename, size_t* file_size) {
    FILE* file = fopen(filename, "rb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", filename);
        return NULL;
    }
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    if (size <= 0) {
        fprintf(stderr, "Error: Input file is empty or invalid\n");
        fclose(file);
        return NULL;
    }
    
    unsigned char* buffer = malloc(size);
    if (buffer == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        fclose(file);
        return NULL;
    }
    
    size_t bytes_read = fread(buffer, 1, size, file);
    fclose(file);
    
    if (bytes_read != (size_t)size) {
        fprintf(stderr, "Error: Failed to read entire file\n");
        free(buffer);
        return NULL;
    }
    
    *file_size = bytes_read;
    return buffer;
}

int write_file(const char* filename, const unsigned char* data, size_t data_size) {
    FILE* file = fopen(filename, "wb");
    if (file == NULL) {
        fprintf(stderr, "Error: Cannot create output file '%s'\n", filename);
        return 0;
    }
    
    size_t bytes_written = fwrite(data, 1, data_size, file);
    fclose(file);
    
    if (bytes_written != data_size) {
        fprintf(stderr, "Error: Failed to write entire file\n");
        return 0;
    }
    
    return 1;
}


====================================================================
–§–ê–ô–õ: ./src/modes/ecb.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../../include/modes/ecb.h"

#define AES_BLOCK_SIZE 16

void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t original_len = *data_len;
    size_t padding_len = AES_BLOCK_SIZE - (original_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = original_len + padding_len;
    unsigned char* new_data = malloc(new_len);
    if (new_data == NULL) {
        fprintf(stderr, "Error: Memory allocation failed for padding\n");
        return;
    }
    
    // Copy original data
    if (original_len > 0 && *data != NULL) {
        memcpy(new_data, *data, original_len);
    }
    
    // Add padding
    for (size_t i = original_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    // Free old data and update pointers
    if (*data != NULL) {
        free(*data);
    }
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte: %d\n", padding_byte);
        return 0;
    }
    
    // Check if padding length is valid
    if (padding_byte > *data_len) {
        fprintf(stderr, "Error: Padding length exceeds data length\n");
        return 0;
    }
    
    // Verify all padding bytes
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Invalid padding bytes at position %zu\n", i);
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}


====================================================================
–§–ê–ô–õ: ./src/modes.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include "crypto.h"
#include "common.h"
#include "types.h"
#include "csprng.h"

// Utility functions
int requires_padding(cipher_mode_t mode) {
    return (mode == CIPHER_MODE_ECB || mode == CIPHER_MODE_CBC);
}

void generate_random_iv(unsigned char* iv, size_t len) {
    if (generate_random_bytes(iv, len) != 0) {
        fprintf(stderr, "Error: Failed to generate cryptographically secure IV\n");
        exit(1);
    }
}

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len) {
    size_t padding_len = AES_BLOCK_SIZE - (*data_len % AES_BLOCK_SIZE);
    if (padding_len == 0) padding_len = AES_BLOCK_SIZE;
    
    size_t new_len = *data_len + padding_len;
    unsigned char* new_data = realloc(*data, new_len);
    if (new_data == NULL) return;
    
    for (size_t i = *data_len; i < new_len; i++) {
        new_data[i] = (unsigned char)padding_len;
    }
    
    *data = new_data;
    *data_len = new_len;
}

int pkcs7_unpad(unsigned char** data, size_t* data_len) {
    if (*data_len == 0 || *data_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Invalid data length for unpadding\n");
        return 0;
    }
    
    unsigned char padding_byte = (*data)[*data_len - 1];
    if (padding_byte == 0 || padding_byte > AES_BLOCK_SIZE) {
        fprintf(stderr, "Error: Invalid padding byte\n");
        return 0;
    }
    
    for (size_t i = *data_len - padding_byte; i < *data_len; i++) {
        if ((*data)[i] != padding_byte) {
            fprintf(stderr, "Error: Padding validation failed\n");
            return 0;
        }
    }
    
    *data_len -= padding_byte;
    return 1;
}

// AES block encryption/decryption helper
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_EncryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL);
    EVP_CIPHER_CTX_set_padding(ctx, 0);
    
    int out_len;
    EVP_DecryptUpdate(ctx, output, &out_len, input, AES_BLOCK_SIZE);
    EVP_CIPHER_CTX_free(ctx);
}

// CBC Mode
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            block[j] = padded_data[i + j] ^ prev_block[j];
        }
        
        // Encrypt the block
        aes_encrypt_block(block, output + i, key);
        memcpy(prev_block, output + i, AES_BLOCK_SIZE);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for CBC decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char block[AES_BLOCK_SIZE];
    unsigned char prev_block[AES_BLOCK_SIZE];
    memcpy(prev_block, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Decrypt the block
        aes_decrypt_block(input + i, block, key);
        
        // XOR with previous ciphertext block (or IV for first block)
        for (size_t j = 0; j < AES_BLOCK_SIZE; j++) {
            output[i + j] = block[j] ^ prev_block[j];
        }
        
        memcpy(prev_block, input + i, AES_BLOCK_SIZE);
    }
    
    // Remove padding
    if (!pkcs7_unpad(&output, &input_len)) {
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}

// CFB Mode - CFB-128 implementation (fixed)
unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with encrypted block to get ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (for CFB-128)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, output + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, output + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char encrypted_block[AES_BLOCK_SIZE];
    
    // Initialize feedback register with IV
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Encrypt the current feedback register
        aes_encrypt_block(feedback, encrypted_block, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR ciphertext with encrypted block to get plaintext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ encrypted_block[j];
        }
        
        // Update feedback register with ciphertext (not plaintext)
        if (block_size == AES_BLOCK_SIZE) {
            memcpy(feedback, input + i, AES_BLOCK_SIZE);
        } else {
            // For partial final block, shift and insert new ciphertext bytes
            memmove(feedback, feedback + block_size, AES_BLOCK_SIZE - block_size);
            memcpy(feedback + AES_BLOCK_SIZE - block_size, input + i, block_size);
        }
    }
    
    *output_len = input_len;
    return output;
}

// OFB Mode
unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char feedback[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(feedback, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting feedback register
        aes_encrypt_block(feedback, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Update feedback register with keystream (not ciphertext)
        memcpy(feedback, keystream, AES_BLOCK_SIZE);
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // OFB decryption is identical to encryption
    return aes_ofb_encrypt(input, input_len, key, iv, output_len);
}

// CTR Mode
unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    unsigned char counter[AES_BLOCK_SIZE];
    unsigned char keystream[AES_BLOCK_SIZE];
    memcpy(counter, iv, AES_BLOCK_SIZE);
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        // Generate keystream by encrypting counter
        aes_encrypt_block(counter, keystream, key);
        
        size_t block_size = (input_len - i < AES_BLOCK_SIZE) ? input_len - i : AES_BLOCK_SIZE;
        
        // XOR plaintext with keystream to produce ciphertext
        for (size_t j = 0; j < block_size; j++) {
            output[i + j] = input[i + j] ^ keystream[j];
        }
        
        // Increment counter (big-endian)
        for (int j = AES_BLOCK_SIZE - 1; j >= 0; j--) {
            if (++counter[j] != 0) break;
        }
    }
    
    *output_len = input_len;
    return output;
}

unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len) {
    // CTR decryption is identical to encryption
    return aes_ctr_encrypt(input, input_len, key, iv, output_len);
}


====================================================================
–§–ê–ô–õ: ./src/csprng.h
====================================================================
#ifndef CSPRNG_H
#define CSPRNG_H

#include <stdlib.h>

/**
 * @brief Generates cryptographically secure random bytes
 * 
 * @param buffer Output buffer for random bytes
 * @param num_bytes Number of bytes to generate
 * @return int 0 on success, -1 on error
 */
int generate_random_bytes(unsigned char *buffer, size_t num_bytes);

/**
 * @brief Generates a random key and returns it as hexadecimal string
 * 
 * @param key_len Length of key in bytes
 * @return char* Hexadecimal string (must be freed by caller), NULL on error
 */
char* generate_random_key_hex(size_t key_len);

#endif


====================================================================
–§–ê–ô–õ: ./src/types.h
====================================================================
#ifndef TYPES_H
#define TYPES_H

typedef enum {
    MODE_ENCRYPT,
    MODE_DECRYPT,
    MODE_UNKNOWN
} operation_mode_t;

typedef enum {
    CIPHER_MODE_ECB,
    CIPHER_MODE_CBC,
    CIPHER_MODE_CFB,
    CIPHER_MODE_OFB,
    CIPHER_MODE_CTR,
    CIPHER_MODE_UNKNOWN
} cipher_mode_t;

#endif


====================================================================
–§–ê–ô–õ: ./src/common.h
====================================================================
#ifndef COMMON_H
#define COMMON_H

#include <stdlib.h>
#include "types.h"

#define AES_BLOCK_SIZE 16

// Padding functions
void pkcs7_pad(unsigned char** data, size_t* data_len);
int pkcs7_unpad(unsigned char** data, size_t* data_len);

// AES block operations
void aes_encrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);
void aes_decrypt_block(const unsigned char* input, unsigned char* output, const unsigned char* key);

#endif


====================================================================
–§–ê–ô–õ: ./src/main.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cli_parser.h"
#include "file_io.h"
#include "crypto.h"
#include "common.h"
#include "types.h"

int main(int argc, char* argv[]) {
    cli_args_t args;
    
    if (!parse_arguments(argc, argv, &args)) {
        print_usage(argv[0]);
        free_cli_args(&args);
        return 1;
    }
    
    // –í—ã–≤–æ–¥–∏–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á –µ—Å–ª–∏ –æ–Ω –±—ã–ª —Å–æ–∑–¥–∞–Ω
    if (args.operation == MODE_ENCRYPT && args.generated_key_hex != NULL) {
        printf("Generated random key: %s\n", args.generated_key_hex);
    }
    
    // Read input file
    size_t input_size;
    unsigned char* input_data = read_file(args.input_file, &input_size);
    if (input_data == NULL) {
        free_cli_args(&args);
        return 1;
    }
    
    // Handle IV based on operation and mode
    unsigned char iv[16];
    const unsigned char* iv_ptr = NULL;
    size_t data_start = 0;
    size_t data_size = input_size;
    
    if (args.operation == MODE_ENCRYPT) {
        // Generate random IV for modes that need it
        if (args.mode != CIPHER_MODE_ECB) {
            generate_random_iv(iv, 16);
            iv_ptr = iv;
        }
    } else { // DECRYPT
        if (args.mode != CIPHER_MODE_ECB) {
            if (args.iv_provided) {
                // Use provided IV
                iv_ptr = args.iv;
            } else {
                // Read IV from file (first 16 bytes)
                if (input_size < 16) {
                    fprintf(stderr, "Error: Input file too short to contain IV\n");
                    free(input_data);
                    free_cli_args(&args);
                    return 1;
                }
                iv_ptr = input_data;
                data_start = 16;
                data_size = input_size - 16;
            }
        }
    }
    
    // Process data
    size_t output_size;
    unsigned char* output_data = NULL;
    unsigned char* final_output = NULL;
    size_t final_size = 0;
    
    switch (args.mode) {
        case CIPHER_MODE_ECB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ecb_encrypt(input_data + data_start, data_size, args.key, &output_size);
            } else {
                output_data = aes_ecb_decrypt(input_data + data_start, data_size, args.key, &output_size);
            }
            break;
        case CIPHER_MODE_CBC:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_cbc_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_cbc_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CFB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_cfb_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_cfb_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_OFB:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ofb_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_ofb_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        case CIPHER_MODE_CTR:
            if (args.operation == MODE_ENCRYPT) {
                output_data = aes_ctr_encrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            } else {
                output_data = aes_ctr_decrypt(input_data + data_start, data_size, args.key, iv_ptr, &output_size);
            }
            break;
        default:
            fprintf(stderr, "Error: Unsupported mode\n");
            free(input_data);
            free_cli_args(&args);
            return 1;
    }
    
    free(input_data);
    
    if (output_data == NULL) {
        fprintf(stderr, "Error: Cryptographic operation failed\n");
        free_cli_args(&args);
        return 1;
    }
    
    // Prepare final output (with IV for encryption)
    if (args.operation == MODE_ENCRYPT && args.mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        final_size = 16 + output_size;
        final_output = malloc(final_size);
        if (final_output) {
            memcpy(final_output, iv_ptr, 16);
            memcpy(final_output + 16, output_data, output_size);
        }
        free(output_data);
    } else {
        final_output = output_data;
        final_size = output_size;
    }
    
    if (final_output == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        free_cli_args(&args);
        return 1;
    }
    
    // Write output file
    if (!write_file(args.output_file, final_output, final_size)) {
        free(final_output);
        free_cli_args(&args);
        return 1;
    }
    
    printf("Success: %s -> %s\n", args.input_file, args.output_file);
    
    // Print IV info for encryption
    if (args.operation == MODE_ENCRYPT && args.mode != CIPHER_MODE_ECB && iv_ptr != NULL) {
        printf("Generated IV: ");
        for (int i = 0; i < 16; i++) {
            printf("%02x", iv_ptr[i]);
        }
        printf("\n");
    }
    
    free(final_output);
    free_cli_args(&args);
    return 0;
}


====================================================================
–§–ê–ô–õ: ./src/cli_parser.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "types.h"
#include "cli_parser.h"
#include "csprng.h"

void print_usage(const char* program_name) {
    fprintf(stderr, "Usage: %s -algorithm aes -mode [ecb|cbc|cfb|ofb|ctr] (-encrypt | -decrypt) [-key HEX_KEY] -input INPUT_FILE [-output OUTPUT_FILE] [-iv HEX_IV]\n", program_name);
    fprintf(stderr, "Examples:\n");
    fprintf(stderr, "  Encryption with generated key: %s -algorithm aes -mode cbc -encrypt -input plain.txt -output cipher.bin\n", program_name);
    fprintf(stderr, "  Encryption with specific key: %s -algorithm aes -mode cbc -encrypt -key 00112233445566778899aabbccddeeff -input plain.txt -output cipher.bin\n", program_name);
    fprintf(stderr, "  Decryption: %s -algorithm aes -mode cbc -decrypt -key 00112233445566778899aabbccddeeff -iv aabbccddeeff00112233445566778899 -input cipher.bin -output decrypted.txt\n", program_name);
    fprintf(stderr, "Supported modes: ecb, cbc, cfb, ofb, ctr\n");
    fprintf(stderr, "Note: For encryption, -key is optional. If omitted, a secure random key will be generated and displayed.\n");
    fprintf(stderr, "Key and IV should be provided as hexadecimal strings WITHOUT @ prefix.\n");
}

cipher_mode_t parse_cipher_mode(const char* mode_str) {
    if (strcmp(mode_str, "ecb") == 0) return CIPHER_MODE_ECB;
    if (strcmp(mode_str, "cbc") == 0) return CIPHER_MODE_CBC;
    if (strcmp(mode_str, "cfb") == 0) return CIPHER_MODE_CFB;
    if (strcmp(mode_str, "ofb") == 0) return CIPHER_MODE_OFB;
    if (strcmp(mode_str, "ctr") == 0) return CIPHER_MODE_CTR;
    return CIPHER_MODE_UNKNOWN;
}

int hex_to_bytes(const char* hex_str, unsigned char** bytes, size_t* len) {
    // –£–±—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ @ - —Ç–µ–ø–µ—Ä—å –∫–ª—é—á–∏ –∏ IV –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞
    size_t hex_len = strlen(hex_str);
    
    if (hex_len == 0 || hex_len % 2 != 0) {
        fprintf(stderr, "Error: Hexadecimal value must have even number of digits\n");
        return 0;
    }
    
    *len = hex_len / 2;
    *bytes = malloc(*len);
    if (*bytes == NULL) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        return 0;
    }
    
    for (size_t i = 0; i < *len; i++) {
        if (sscanf(hex_str + 2*i, "%2hhx", &(*bytes)[i]) != 1) {
            fprintf(stderr, "Error: Invalid hexadecimal character at position %zu\n", 2*i);
            free(*bytes);
            *bytes = NULL;
            return 0;
        }
    }
    
    return 1;
}

int parse_arguments(int argc, char* argv[], cli_args_t* args) {
    memset(args, 0, sizeof(cli_args_t));
    args->operation = MODE_UNKNOWN;
    args->mode = CIPHER_MODE_UNKNOWN;
    
    int encrypt_flag = 0;
    int decrypt_flag = 0;
    char* mode_str = NULL;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-algorithm") == 0 && i + 1 < argc) {
            args->algorithm = malloc(strlen(argv[i+1]) + 1);
            if (args->algorithm) strcpy(args->algorithm, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-mode") == 0 && i + 1 < argc) {
            mode_str = malloc(strlen(argv[i+1]) + 1);
            if (mode_str) strcpy(mode_str, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-encrypt") == 0) {
            encrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-decrypt") == 0) {
            decrypt_flag = 1;
        }
        else if (strcmp(argv[i], "-key") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->key, &args->key_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            i++;
        }
        else if (strcmp(argv[i], "-iv") == 0 && i + 1 < argc) {
            if (!hex_to_bytes(argv[i+1], &args->iv, &args->iv_len)) {
                if (mode_str) free(mode_str);
                return 0;
            }
            args->iv_provided = 1;
            i++;
        }
        else if (strcmp(argv[i], "-input") == 0 && i + 1 < argc) {
            args->input_file = malloc(strlen(argv[i+1]) + 1);
            if (args->input_file) strcpy(args->input_file, argv[i+1]);
            i++;
        }
        else if (strcmp(argv[i], "-output") == 0 && i + 1 < argc) {
            args->output_file = malloc(strlen(argv[i+1]) + 1);
            if (args->output_file) strcpy(args->output_file, argv[i+1]);
            i++;
        }
        else {
            fprintf(stderr, "Error: Unknown argument '%s'\n", argv[i]);
            print_usage(argv[0]);
            if (mode_str) free(mode_str);
            return 0;
        }
    }
    
    // Parse cipher mode
    if (mode_str) {
        args->mode = parse_cipher_mode(mode_str);
        free(mode_str);
    }
    
    // Set operation mode based on flags
    if (encrypt_flag && decrypt_flag) {
        fprintf(stderr, "Error: Cannot specify both -encrypt and -decrypt\n");
        return 0;
    }
    else if (encrypt_flag) {
        args->operation = MODE_ENCRYPT;
    }
    else if (decrypt_flag) {
        args->operation = MODE_DECRYPT;
    }
    
    // Validation
    if (args->algorithm == NULL || strcmp(args->algorithm, "aes") != 0) {
        fprintf(stderr, "Error: Algorithm must be 'aes'\n");
        return 0;
    }
    
    if (args->mode == CIPHER_MODE_UNKNOWN) {
        fprintf(stderr, "Error: Mode must be one of: ecb, cbc, cfb, ofb, ctr\n");
        return 0;
    }
    
    if (args->operation == MODE_UNKNOWN) {
        fprintf(stderr, "Error: Must specify either -encrypt or -decrypt\n");
        return 0;
    }
    
    // KEY VALIDATION - UPDATED FOR MILESTONE 3
    if (args->operation == MODE_ENCRYPT && args->key == NULL) {
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á
        char* generated_key_hex = generate_random_key_hex(16);
        if (generated_key_hex == NULL) {
            fprintf(stderr, "Error: Failed to generate random key\n");
            return 0;
        }
        
        // –ü–∞—Ä—Å–∏–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á –∫–∞–∫ –æ–±—ã—á–Ω—ã–π hex
        if (!hex_to_bytes(generated_key_hex, &args->key, &args->key_len)) {
            free(generated_key_hex);
            return 0;
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º hex –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤—ã–≤–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        args->generated_key_hex = generated_key_hex;
    } else if (args->key == NULL) {
        // –î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∫–ª—é—á –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω
        fprintf(stderr, "Error: Key is required for decryption\n");
        return 0;
    } else if (args->key_len != 16) {
        fprintf(stderr, "Error: Key must be 16 bytes for AES-128\n");
        return 0;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∞–±—ã–µ –∫–ª—é—á–∏ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ)
    if (args->key != NULL && args->operation == MODE_ENCRYPT && args->generated_key_hex == NULL) {
        int is_weak = 1;
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—Å–µ –ª–∏ –±–∞–π—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ
        for (size_t i = 1; i < args->key_len; i++) {
            if (args->key[i] != args->key[0]) {
                is_weak = 0;
                break;
            }
        }
        
        if (is_weak) {
            fprintf(stderr, "Warning: The provided key may be weak (all bytes identical)\n");
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –±–∞–π—Ç—ã
        is_weak = 1;
        for (size_t i = 1; i < args->key_len; i++) {
            if (args->key[i] != args->key[i-1] + 1) {
                is_weak = 0;
                break;
            }
        }
        
        if (is_weak) {
            fprintf(stderr, "Warning: The provided key may be weak (sequential bytes)\n");
        }
    }
    
    if (args->input_file == NULL) {
        fprintf(stderr, "Error: Input file is required\n");
        return 0;
    }
    
    // IV validation
    if (args->operation == MODE_ENCRYPT && args->iv_provided) {
        fprintf(stderr, "Warning: IV provided during encryption will be ignored (using random IV)\n");
        free(args->iv);
        args->iv = NULL;
        args->iv_provided = 0;
    }
    
    if (args->operation == MODE_DECRYPT && args->mode != CIPHER_MODE_ECB && !args->iv_provided) {
        fprintf(stderr, "Warning: No IV provided for decryption, will read from file\n");
    }
    
    if (args->iv_provided && args->iv_len != 16) {
        fprintf(stderr, "Error: IV must be 16 bytes\n");
        return 0;
    }
    
    if (args->output_file == NULL) {
        // Generate default output filename
        const char* extension = (args->operation == MODE_ENCRYPT) ? ".enc" : ".dec";
        size_t len = strlen(args->input_file) + strlen(extension) + 1;
        args->output_file = malloc(len);
        if (args->output_file) {
            snprintf(args->output_file, len, "%s%s", args->input_file, extension);
        }
    }
    
    return 1;
}

void free_cli_args(cli_args_t* args) {
    if (args->algorithm) free(args->algorithm);
    if (args->key) free(args->key);
    if (args->input_file) free(args->input_file);
    if (args->output_file) free(args->output_file);
    if (args->iv) free(args->iv);
    if (args->generated_key_hex) free(args->generated_key_hex);
}


====================================================================
–§–ê–ô–õ: ./src/file_io.h
====================================================================
#ifndef FILE_IO_H
#define FILE_IO_H

#include <stdlib.h>

unsigned char* read_file(const char* filename, size_t* file_size);
int write_file(const char* filename, const unsigned char* data, size_t data_size);

#endif


====================================================================
–§–ê–ô–õ: ./src/crypto.h
====================================================================
#ifndef CRYPTO_H
#define CRYPTO_H

#include <stdlib.h>
#include "types.h"

// Existing ECB functions
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);
unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len);

// New mode functions
unsigned char* aes_cbc_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cbc_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_cfb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_cfb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ofb_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ofb_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

unsigned char* aes_ctr_encrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);
unsigned char* aes_ctr_decrypt(const unsigned char* input, size_t input_len,
                              const unsigned char* key, const unsigned char* iv,
                              size_t* output_len);

// Utility functions
int requires_padding(cipher_mode_t mode);
void generate_random_iv(unsigned char* iv, size_t len);

#endif


====================================================================
–§–ê–ô–õ: ./src/crypto.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include "crypto.h"
#include "common.h"

// Keep existing ECB functions but update them to use new helper functions
unsigned char* aes_ecb_encrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    unsigned char* padded_data = malloc(input_len);
    if (!padded_data) return NULL;
    memcpy(padded_data, input, input_len);
    size_t padded_len = input_len;
    
    pkcs7_pad(&padded_data, &padded_len);
    
    unsigned char* output = malloc(padded_len);
    if (!output) {
        free(padded_data);
        return NULL;
    }
    
    for (size_t i = 0; i < padded_len; i += AES_BLOCK_SIZE) {
        aes_encrypt_block(padded_data + i, output + i, key);
    }
    
    free(padded_data);
    *output_len = padded_len;
    return output;
}

unsigned char* aes_ecb_decrypt(const unsigned char* input, size_t input_len, 
                              const unsigned char* key, size_t* output_len) {
    if (input_len % AES_BLOCK_SIZE != 0) {
        fprintf(stderr, "Error: Input length must be multiple of block size for ECB decryption\n");
        return NULL;
    }
    
    unsigned char* output = malloc(input_len);
    if (!output) return NULL;
    
    for (size_t i = 0; i < input_len; i += AES_BLOCK_SIZE) {
        aes_decrypt_block(input + i, output + i, key);
    }
    
    if (!pkcs7_unpad(&output, &input_len)) {
        fprintf(stderr, "Error: PKCS#7 unpadding failed in ECB mode\n");
        free(output);
        return NULL;
    }
    
    *output_len = input_len;
    return output;
}


====================================================================
–§–ê–ô–õ: ./src/cli_parser.h
====================================================================
#ifndef CLI_PARSER_H
#define CLI_PARSER_H

#include <stdlib.h>
#include "types.h"

typedef struct {
    operation_mode_t operation;
    cipher_mode_t mode;
    char* algorithm;
    unsigned char* key;
    size_t key_len;
    char* input_file;
    char* output_file;
    unsigned char* iv;
    size_t iv_len;
    int iv_provided;
    char* generated_key_hex; // NEW: –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ hex
} cli_args_t;

int parse_arguments(int argc, char* argv[], cli_args_t* args);
void free_cli_args(cli_args_t* args);
void print_usage(const char* program_name);
cipher_mode_t parse_cipher_mode(const char* mode_str);

#endif


====================================================================
–§–ê–ô–õ: ./src/csprng.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
#include "csprng.h"

int generate_random_bytes(unsigned char *buffer, size_t num_bytes) {
    if (buffer == NULL || num_bytes == 0) {
        fprintf(stderr, "Error: Invalid parameters for random generation\n");
        return -1;
    }
    
    if (RAND_bytes(buffer, num_bytes) != 1) {
        fprintf(stderr, "Error: Cryptographically secure random generation failed\n");
        return -1;
    }
    
    return 0;
}

char* generate_random_key_hex(size_t key_len) {
    unsigned char* key_bytes = malloc(key_len);
    if (key_bytes == NULL) {
        fprintf(stderr, "Error: Memory allocation failed for key generation\n");
        return NULL;
    }
    
    if (generate_random_bytes(key_bytes, key_len) != 0) {
        free(key_bytes);
        return NULL;
    }
    
    // Convert to hexadecimal string (–ë–ï–ó @ –≤ –Ω–∞—á–∞–ª–µ!)
    char* hex_string = malloc(key_len * 2 + 1); // +1 for null terminator
    if (hex_string == NULL) {
        free(key_bytes);
        return NULL;
    }
    
    for (size_t i = 0; i < key_len; i++) {
        sprintf(hex_string + i * 2, "%02x", key_bytes[i]);
    }
    
    free(key_bytes);
    return hex_string;
}


====================================================================
–§–ê–ô–õ: ./tests/test_csprng.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "../src/csprng.h"

void test_key_uniqueness() {
    printf("Testing key uniqueness...\n");
    
    const int NUM_KEYS = 1000;
    char* keys[NUM_KEYS];
    
    // Generate 1000 keys
    for (int i = 0; i < NUM_KEYS; i++) {
        keys[i] = generate_random_key_hex(16);
        assert(keys[i] != NULL);
        
        // Check for duplicates with all previous keys
        for (int j = 0; j < i; j++) {
            if (strcmp(keys[i], keys[j]) == 0) {
                printf("ERROR: Duplicate key found at indices %d and %d: %s\n", i, j, keys[i]);
                exit(1);
            }
        }
    }
    
    printf("‚úì Successfully generated %d unique keys\n", NUM_KEYS);
    
    // Cleanup
    for (int i = 0; i < NUM_KEYS; i++) {
        free(keys[i]);
    }
}

void test_basic_distribution() {
    printf("Testing basic distribution...\n");
    
    const int NUM_SAMPLES = 10000;
    const int KEY_LEN = 16;
    unsigned char buffer[KEY_LEN];
    
    int total_bits = NUM_SAMPLES * KEY_LEN * 8;
    int ones_count = 0;
    
    for (int i = 0; i < NUM_SAMPLES; i++) {
        assert(generate_random_bytes(buffer, KEY_LEN) == 0);
        
        for (int j = 0; j < KEY_LEN; j++) {
            for (int bit = 0; bit < 8; bit++) {
                if (buffer[j] & (1 << bit)) {
                    ones_count++;
                }
            }
        }
    }
    
    double ratio = (double)ones_count / total_bits;
    printf("Bit ratio (1s/total): %.4f (should be close to 0.5)\n", ratio);
    
    // Check if ratio is reasonably close to 50%
    assert(ratio > 0.49 && ratio < 0.51);
    printf("‚úì Basic distribution test passed\n");
}

void test_nist_preparation() {
    printf("Preparing data for NIST tests...\n");
    
    const size_t TOTAL_SIZE = 10000000; // 10 MB
    const size_t CHUNK_SIZE = 4096;
    unsigned char buffer[CHUNK_SIZE];
    
    FILE* f = fopen("nist_test_data.bin", "wb");
    assert(f != NULL);
    
    size_t bytes_written = 0;
    while (bytes_written < TOTAL_SIZE) {
        size_t chunk = (TOTAL_SIZE - bytes_written < CHUNK_SIZE) ? 
                      TOTAL_SIZE - bytes_written : CHUNK_SIZE;
        
        assert(generate_random_bytes(buffer, chunk) == 0);
        size_t written = fwrite(buffer, 1, chunk, f);
        assert(written == chunk);
        
        bytes_written += written;
    }
    
    fclose(f);
    printf("‚úì Generated %zu bytes for NIST testing in 'nist_test_data.bin'\n", bytes_written);
}

int main() {
    printf("=== CSPRNG Comprehensive Tests ===\n\n");
    
    test_key_uniqueness();
    printf("\n");
    
    test_basic_distribution();
    printf("\n");
    
    test_nist_preparation();
    printf("\n");
    
    printf("=== All CSPRNG tests passed! ===\n");
    return 0;
}


====================================================================
–§–ê–ô–õ: ./tests/fixed_interop_test.sh
====================================================================
#!/bin/bash

# Fixed Interoperability Test Script

echo "=== Fixed CryptoCore OpenSSL Interoperability Test ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    echo "Please build the project first using 'make' in the root directory"
    exit 1
fi

# Create test directory
mkdir -p test_files
cd test_files

# Create test file with specific size (multiple of 16 bytes for no-padding tests)
echo -n "0123456789ABCDEF" > "test_16.txt"  # 16 bytes
echo "This is a test file for CryptoCore interoperability testing." > "test_text.txt"

echo "=== Testing Round-trip First ==="

# Test round-trip for all modes
for mode in ecb cbc cfb ofb ctr; do
    echo "Testing $mode round-trip..."
    "$BIN" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "test_16.txt" -output "test_${mode}.enc"
    "$BIN" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "test_${mode}.enc" -output "test_${mode}.dec"
    
    if diff "test_16.txt" "test_${mode}.dec" > /dev/null; then
        echo "‚úì $mode round-trip OK"
    else
        echo "‚úó $mode round-trip FAILED"
    fi
done

echo ""
echo "=== Testing OpenSSL Interoperability ==="

# Test 1: CryptoCore -> OpenSSL (ECB)
echo "1. CryptoCore -> OpenSSL (ECB)"
"$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "test_16.txt" -output "cc_ecb.enc"

# OpenSSL decryption
if openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "cc_ecb.enc" -out "os_ecb.dec" -nopad 2>/dev/null; then
    if diff "test_16.txt" "os_ecb.dec" > /dev/null; then
        echo "   ‚úì ECB: CryptoCore -> OpenSSL OK"
    else
        echo "   ‚úó ECB: CryptoCore -> OpenSSL FAILED - files differ"
        echo "   Original size: $(stat -c%s test_16.txt), Decrypted: $(stat -c%s os_ecb.dec)"
    fi
else
    echo "   ‚úó ECB: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
fi

# Test 2: OpenSSL -> CryptoCore (ECB)  
echo "2. OpenSSL -> CryptoCore (ECB)"
if openssl enc -aes-128-ecb -K "$KEY_HEX" -in "test_16.txt" -out "os_ecb.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "os_ecb.enc" -output "cc_ecb.dec"

    if diff "test_16.txt" "cc_ecb.dec" > /dev/null; then
        echo "   ‚úì ECB: OpenSSL -> CryptoCore OK"
    else
        echo "   ‚úó ECB: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   ‚úó ECB: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test 3: CryptoCore -> OpenSSL (CBC)
echo "3. CryptoCore -> OpenSSL (CBC)"
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_16.txt" -output "cc_cbc.enc"

# Extract IV and ciphertext
dd if="cc_cbc.enc" of="iv.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc.enc" of="ciphertext.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv.bin" ] && [ -f "ciphertext.bin" ]; then
    IV_FROM_FILE=$(xxd -p "iv.bin" | tr -d '\n')

    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "ciphertext.bin" -out "os_cbc.dec" -nopad 2>/dev/null; then
        if diff "test_16.txt" "os_cbc.dec" > /dev/null; then
            echo "   ‚úì CBC: CryptoCore -> OpenSSL OK"
        else
            echo "   ‚úó CBC: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   ‚úó CBC: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   ‚úó CBC: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Test 4: OpenSSL -> CryptoCore (CBC)
echo "4. OpenSSL -> CryptoCore (CBC)"
if openssl enc -aes-128-cbc -K "$KEY_HEX" -iv "00000000000000000000000000000000" -in "test_16.txt" -out "os_cbc.enc" -nopad 2>/dev/null; then
    "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -iv "@00000000000000000000000000000000" -input "os_cbc.enc" -output "cc_cbc.dec"

    if diff "test_16.txt" "cc_cbc.dec" > /dev/null; then
        echo "   ‚úì CBC: OpenSSL -> CryptoCore OK"
    else
        echo "   ‚úó CBC: OpenSSL -> CryptoCore FAILED - files differ"
    fi
else
    echo "   ‚úó CBC: OpenSSL -> CryptoCore FAILED - OpenSSL encryption error"
fi

# Test with text files (with padding)
echo ""
echo "=== Testing with Padding ==="

# CryptoCore CBC with text (auto padding)
echo "Testing CBC with padding..."
"$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "test_text.txt" -output "cc_cbc_pad.enc"

# Extract IV and ciphertext
dd if="cc_cbc_pad.enc" of="iv_pad.bin" bs=16 count=1 status=none 2>/dev/null
dd if="cc_cbc_pad.enc" of="ciphertext_pad.bin" bs=16 skip=1 status=none 2>/dev/null

if [ -f "iv_pad.bin" ] && [ -f "ciphertext_pad.bin" ]; then
    IV_PAD=$(xxd -p "iv_pad.bin" | tr -d '\n')

    # OpenSSL decryption with padding (no -nopad flag)
    if openssl enc -aes-128-cbc -d -K "$KEY_HEX" -iv "$IV_PAD" -in "ciphertext_pad.bin" -out "os_cbc_pad.dec" 2>/dev/null; then
        if diff "test_text.txt" "os_cbc_pad.dec" > /dev/null; then
            echo "   ‚úì CBC with padding: CryptoCore -> OpenSSL OK"
        else
            echo "   ‚úó CBC with padding: CryptoCore -> OpenSSL FAILED - files differ"
        fi
    else
        echo "   ‚úó CBC with padding: CryptoCore -> OpenSSL FAILED - OpenSSL decryption error"
    fi
else
    echo "   ‚úó CBC with padding: CryptoCore -> OpenSSL FAILED - could not extract IV/ciphertext"
fi

# Cleanup
cd ..
rm -rf test_files

echo ""
echo "=== Interoperability Test Complete ==="


====================================================================
–§–ê–ô–õ: ./tests/safe_test.sh
====================================================================
#!/bin/bash

echo "=== SAFE CRYPTOCORE TESTS (–±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤) ==="

BIN="../bin/cryptocore"
KEY="@00112233445566778899aabbccddeeff"

# –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±–∏–Ω–∞—Ä–Ω–∏–∫ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
if [ ! -f "$BIN" ]; then
    echo "–û–®–ò–ë–ö–ê: cryptocore –±–∏–Ω–∞—Ä–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω!"
    exit 1
fi

echo "‚úì –ë–∏–Ω–∞—Ä–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω"
echo "‚úì –¢–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã"
echo

# –¢–µ—Å—Ç 1: –ë–∞–∑–æ–≤—ã–µ —Ä–µ–∂–∏–º—ã
echo "--- –¢–ï–°–¢ 1: –ë–ê–ó–û–í–´–ï –†–ï–ñ–ò–ú–´ ---"
for mode in ecb cbc cfb ofb ctr; do
    echo -n "–¢–µ—Å—Ç–∏—Ä—É—é $mode... "
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input test_files/test1.txt -output test_${mode}.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input test_${mode}.enc -output test_${mode}.dec
    
    if diff test_files/test1.txt test_${mode}.dec > /dev/null 2>&1; then
        echo "‚úÖ –£–°–ü–ï–•"
    else
        echo "‚ùå –û–®–ò–ë–ö–ê"
    fi
done

echo

# –¢–µ—Å—Ç 2: –†–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã —Ñ–∞–π–ª–æ–≤
echo "--- –¢–ï–°–¢ 2: –†–ê–ó–ù–´–ï –†–ê–ó–ú–ï–†–´ –§–ê–ô–õ–û–í ---"
echo -n "16 –±–∞–π—Ç (–±–µ–∑ padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_files/test_16_bytes.txt -output test_16_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input test_16_enc.enc -output test_16_dec.txt
diff test_files/test_16_bytes.txt test_16_dec.txt > /dev/null 2>&1 && echo "‚úÖ –£–°–ü–ï–•" || echo "‚ùå –û–®–ò–ë–ö–ê"

echo -n "15 –±–∞–π—Ç (—Ç—Ä–µ–±—É–µ—Ç padding)... "
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_files/test_15_bytes.txt -output test_15_enc.enc
$BIN -algorithm aes -mode ecb -decrypt -key $KEY -input test_15_enc.enc -output test_15_dec.txt
diff test_files/test_15_bytes.txt test_15_dec.txt > /dev/null 2>&1 && echo "‚úÖ –£–°–ü–ï–•" || echo "‚ùå –û–®–ò–ë–ö–ê"

echo

# –¢–µ—Å—Ç 3: –ë–∏–Ω–∞—Ä–Ω—ã–µ —Ñ–∞–π–ª—ã
echo "--- –¢–ï–°–¢ 3: –ë–ò–ù–ê–†–ù–´–ï –§–ê–ô–õ–´ ---"
echo -n "–°–ª—É—á–∞–π–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ... "
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_files/random_binary.bin -output test_bin_enc.enc
$BIN -algorithm aes -mode cbc -decrypt -key $KEY -input test_bin_enc.enc -output test_bin_dec.bin
diff test_files/random_binary.bin test_bin_dec.bin > /dev/null 2>&1 && echo "‚úÖ –£–°–ü–ï–•" || echo "‚ùå –û–®–ò–ë–ö–ê"

echo

# –¢–µ—Å—Ç 4: IV —Ä–∞–±–æ—Ç–∞
echo "--- –¢–ï–°–¢ 4: –ü–†–û–í–ï–†–ö–ê IV ---"
echo "–®–∏—Ñ—Ä—É–µ–º CBC —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º IV..."
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_files/test1.txt -output test_cbc_iv.enc
echo "–†–∞–∑–º–µ—Ä –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: $(stat -c%s test_cbc_iv.enc) –±–∞–π—Ç"
echo "–ü–µ—Ä–≤—ã–µ 32 –±–∞–π—Ç–∞ (hex):"
xxd -l 32 test_cbc_iv.enc

echo

# –û—á–∏—â–∞–µ–º —Ç–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã —Ç–µ—Å—Ç–æ–≤ (–Ω–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã)
echo "–û—á–∏—â–∞—é –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã —Ç–µ—Å—Ç–æ–≤..."
rm -f test_*.enc test_*.dec test_*.bin

echo "=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û ==="
echo "‚úì –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ test_files/"
echo "‚úì –í—Å–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã —É–¥–∞–ª–µ–Ω—ã"



====================================================================
–§–ê–ô–õ: ./tests/test_key_generation.sh
====================================================================
#!/bin/bash

echo "=== Key Generation Integration Test ==="

BIN="./bin/cryptocore"  # –ò–ó–ú–ï–ù–ò–õ–ò –° ../bin/cryptocore –Ω–∞ ./bin/cryptocore
TEST_FILE="test_key_gen.txt"

# Create test file
echo "Test data for key generation" > "$TEST_FILE"

echo "1. Testing encryption with auto-generated key..."
output=$("$BIN" -algorithm aes -mode cbc -encrypt -input "$TEST_FILE" -output "encrypted.bin" 2>&1)

# Extract key from output (–Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –±–µ–∑ @)
if echo "$output" | grep -q "Generated random key: [0-9a-fA-F]\{32\}"; then
    generated_key=$(echo "$output" | grep "Generated random key: " | cut -d' ' -f4)
    echo "‚úì Key generation successful: $generated_key"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–ª—é—á –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç @
    if echo "$generated_key" | grep -q "@"; then
        echo "‚úó Key contains @ prefix - this should not happen!"
        exit 1
    fi
else
    echo "‚úó Key generation failed or wrong format"
    echo "Output was: $output"
    exit 1
fi

echo "2. Testing decryption with generated key..."
if "$BIN" -algorithm aes -mode cbc -decrypt -key "$generated_key" -input "encrypted.bin" -output "decrypted.txt"; then
    echo "‚úì Decryption with generated key successful"
else
    echo "‚úó Decryption with generated key failed"
    exit 1
fi

echo "3. Verifying file integrity..."
if diff "$TEST_FILE" "decrypted.txt" > /dev/null; then
    echo "‚úì File integrity verified"
else
    echo "‚úó File integrity check failed"
    exit 1
fi

echo "4. Testing that decryption requires key..."
if "$BIN" -algorithm aes -mode cbc -decrypt -input "encrypted.bin" -output "should_fail.txt" 2>/dev/null; then
    echo "‚úó Decryption without key should have failed"
    exit 1
else
    echo "‚úì Decryption correctly requires key"
fi

# Test with new key format (–±–µ–∑ @)
echo "5. Testing encryption with explicit key (new format)..."
if "$BIN" -algorithm aes -mode ecb -encrypt -key "$generated_key" -input "$TEST_FILE" -output "explicit_encrypted.bin"; then
    echo "‚úì Encryption with explicit key (new format) successful"
else
    echo "‚úó Encryption with explicit key failed"
    exit 1
fi

# Cleanup
rm -f "$TEST_FILE" "encrypted.bin" "decrypted.txt" "should_fail.txt" "explicit_encrypted.bin"

echo ""
echo "=== All Key Generation Tests Passed! ==="


====================================================================
–§–ê–ô–õ: ./tests/debug_test.sh
====================================================================
#!/bin/bash

# Debug script to test individual modes

set -e

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY="@00112233445566778899aabbccddeeff"
IV="@aabbccddeeff00112233445566778899"

mkdir -p "$TEST_DIR"

# Create test file
echo "Hello, CryptoCore! This is a test." > "$TEST_DIR/debug_test.txt"

test_single_mode() {
    local mode=$1
    local input_file="$TEST_DIR/debug_test.txt"
    local encrypted_file="$TEST_DIR/debug_$mode.enc"
    local decrypted_file="$TEST_DIR/debug_$mode.dec"
    
    echo "=== Testing $mode mode ==="
    
    # Clean up
    rm -f "$encrypted_file" "$decrypted_file"
    
    # Encrypt
    echo "Encrypting..."
    if "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file"; then
        echo "‚úì Encryption successful"
        echo "Encrypted file size: $(stat -c%s "$encrypted_file") bytes"
        
        # Show first 32 bytes of encrypted file in hex
        echo "First 32 bytes (hex):"
        xxd -l 32 "$encrypted_file"
    else
        echo "‚úó Encryption failed"
        return 1
    fi
    
    # Decrypt
    echo "Decrypting..."
    if [ "$mode" = "ecb" ]; then
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "‚úì Decryption successful"
        else
            echo "‚úó Decryption failed"
            return 1
        fi
    else
        # Try both with and without IV
        echo "Trying decryption without IV (read from file)..."
        if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file"; then
            echo "‚úì Decryption successful (IV from file)"
        else
            echo "Trying decryption with explicit IV..."
            if "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$encrypted_file" -output "$decrypted_file"; then
                echo "‚úì Decryption successful (with explicit IV)"
            else
                echo "‚úó All decryption attempts failed"
                return 1
            fi
        fi
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null; then
        echo "‚úì Round-trip successful - files are identical"
        return 0
    else
        echo "‚úó Round-trip failed - files differ"
        echo "Original: $(stat -c%s "$input_file") bytes"
        echo "Decrypted: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test specific mode or all
if [ $# -eq 1 ]; then
    test_single_mode "$1"
else
    echo "Usage: $0 [mode]"
    echo "Modes: ecb, cbc, cfb, ofb, ctr"
    echo ""
    echo "Available tests:"
    echo "  ./test_roundtrip.sh    - Basic round-trip tests"
    echo "  ./test_interoperability.sh - OpenSSL compatibility tests"
    echo "  ./debug_test.sh [mode] - Debug individual mode"
fi


====================================================================
–§–ê–ô–õ: ./tests/test_interoperability.sh
====================================================================
#!/bin/bash

# CryptoCore OpenSSL Interoperability Test Script
# Tests compatibility between CryptoCore and OpenSSL

set -e

echo "=== CryptoCore OpenSSL Interoperability Tests ==="
echo

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"
IV_HEX="aabbccddeeff00112233445566778899"
IV="@$IV_HEX"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Check if OpenSSL is available
if ! command -v openssl &> /dev/null; then
    echo -e "${RED}Error: openssl command not found${NC}"
    echo "Install with: sudo apt-get install openssl"
    exit 1
fi

# Check if xxd is available
if ! command -v xxd &> /dev/null; then
    echo -e "${RED}Error: xxd command not found${NC}"
    echo "Install with: sudo apt-get install xxd"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test file
echo "This is a test file for interoperability testing." > "$TEST_DIR/interop_test.txt"
TEST_FILE_SIZE=$(stat -c%s "$TEST_DIR/interop_test.txt")
echo "Test file size: $TEST_FILE_SIZE bytes"

# Test function for CryptoCore -> OpenSSL
test_cryptocore_to_openssl() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local cryptocore_encrypted="$TEST_DIR/interop_${mode}_cryptocore.enc"
    local iv_file="$TEST_DIR/iv.bin"
    local ciphertext_only="$TEST_DIR/ciphertext_only.bin"
    local openssl_decrypted="$TEST_DIR/decrypted_openssl.txt"
    
    echo "Testing CryptoCore -> OpenSSL for $mode mode..."
    
    # Clean up any existing files
    rm -f "$cryptocore_encrypted" "$iv_file" "$ciphertext_only" "$openssl_decrypted"
    
    # Encrypt with CryptoCore
    echo "Encrypting with CryptoCore..."
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$cryptocore_encrypted" 2>/dev/null; then
        echo -e "${RED}FAIL: CryptoCore encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$cryptocore_encrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore encrypted file not created for $mode${NC}"
        return 1
    fi
    
    local encrypted_size=$(stat -c%s "$cryptocore_encrypted")
    echo "CryptoCore encrypted file size: $encrypted_size bytes"
    
    if [ "$mode" != "ecb" ]; then
        # Extract IV and ciphertext for modes that use IV
        echo "Extracting IV and ciphertext..."
        dd if="$cryptocore_encrypted" of="$iv_file" bs=16 count=1 status=none
        dd if="$cryptocore_encrypted" of="$ciphertext_only" bs=16 skip=1 status=none
        
        # Check if extraction worked
        if [ ! -f "$iv_file" ] || [ ! -f "$ciphertext_only" ]; then
            echo -e "${RED}FAIL: Failed to extract IV or ciphertext for $mode${NC}"
            return 1
        fi
        
        # Get IV as hex string
        IV_FROM_FILE=$(xxd -p "$iv_file" | tr -d '\n')
        echo "IV from file: $IV_FROM_FILE"
        
        # Decrypt with OpenSSL
        echo "Decrypting with OpenSSL..."
        if ! openssl enc -aes-128-$openssl_mode -d -K "$KEY_HEX" -iv "$IV_FROM_FILE" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    else
        # ECB mode - no IV
        cp "$cryptocore_encrypted" "$ciphertext_only"
        echo "Decrypting ECB with OpenSSL..."
        if ! openssl enc -aes-128-ecb -d -K "$KEY_HEX" -in "$ciphertext_only" -out "$openssl_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$openssl_decrypted" ]; then
        echo -e "${RED}FAIL: OpenSSL decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$openssl_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: CryptoCore -> OpenSSL successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: CryptoCore -> OpenSSL failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$openssl_decrypted") bytes"
        return 1
    fi
}

# Test function for OpenSSL -> CryptoCore
test_openssl_to_cryptocore() {
    local mode=$1
    local openssl_mode=$2
    local input_file="$TEST_DIR/interop_test.txt"
    local openssl_encrypted="$TEST_DIR/interop_${mode}_openssl.enc"
    local cryptocore_decrypted="$TEST_DIR/decrypted_cryptocore.txt"
    
    echo "Testing OpenSSL -> CryptoCore for $mode mode..."
    
    # Clean up any existing files
    rm -f "$openssl_encrypted" "$cryptocore_decrypted"
    
    # Encrypt with OpenSSL
    echo "Encrypting with OpenSSL..."
    if [ "$mode" != "ecb" ]; then
        if ! openssl enc -aes-128-$openssl_mode -K "$KEY_HEX" -iv "$IV_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        # Check if encrypted file was created
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        # Decrypt with CryptoCore using provided IV
        echo "Decrypting with CryptoCore..."
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -iv "$IV" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    else
        # ECB mode - no IV
        if ! openssl enc -aes-128-ecb -K "$KEY_HEX" -in "$input_file" -out "$openssl_encrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: OpenSSL encryption failed for $mode${NC}"
            return 1
        fi
        
        if [ ! -f "$openssl_encrypted" ]; then
            echo -e "${RED}FAIL: OpenSSL encrypted file not created for $mode${NC}"
            return 1
        fi
        
        local encrypted_size=$(stat -c%s "$openssl_encrypted")
        echo "OpenSSL encrypted file size: $encrypted_size bytes"
        
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$openssl_encrypted" -output "$cryptocore_decrypted" 2>/dev/null; then
            echo -e "${RED}FAIL: CryptoCore decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$cryptocore_decrypted" ]; then
        echo -e "${RED}FAIL: CryptoCore decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$cryptocore_decrypted" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: OpenSSL -> CryptoCore successful for $mode${NC}"
        return 0
    else
        echo -e "${RED}FAIL: OpenSSL -> CryptoCore failed for $mode - files differ${NC}"
        echo "Original size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted size: $(stat -c%s "$cryptocore_decrypted") bytes"
        return 1
    fi
}

# Clean up before starting
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
openssl_modes=("ecb" "cbc" "cfb" "ofb" "ctr")

passed=0
total=0

echo "=== CryptoCore -> OpenSSL Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_cryptocore_to_openssl "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

echo "=== OpenSSL -> CryptoCore Tests ==="
for i in "${!modes[@]}"; do
    mode="${modes[$i]}"
    openssl_mode="${openssl_modes[$i]}"
    
    if test_openssl_to_cryptocore "$mode" "$openssl_mode"; then
        ((passed++))
    fi
    ((total++))
    echo
done

# Final cleanup
rm -f "$TEST_DIR"/interop_* "$TEST_DIR"/decrypted_* "$TEST_DIR"/iv.bin "$TEST_DIR"/ciphertext_only.bin "$TEST_DIR"/interop_test.txt

echo "=== Interoperability Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All interoperability tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some interoperability tests failed!${NC}"
    exit 1
fi


====================================================================
–§–ê–ô–õ: ./tests/test_roundtrip.c
====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "../src/crypto.h"
#include "../src/file_io.h"
#include "../src/csprng.h"

void test_roundtrip_mode(const char* mode_name, cipher_mode_t mode, int requires_iv) {
    printf("Testing %s mode... ", mode_name);
    
    // Generate random key and IV
    unsigned char key[16];
    unsigned char iv[16];
    
    assert(generate_random_bytes(key, 16) == 0);
    if (requires_iv) {
        assert(generate_random_bytes(iv, 16) == 0);
    }
    
    // Create test data
    unsigned char test_data_15[] = "15 bytes test!!";
    
    size_t encrypted_len, decrypted_len;
    unsigned char* encrypted;
    unsigned char* decrypted;
    
    // Test with 15 bytes
    if (requires_iv) {
        encrypted = NULL;
        if (mode == CIPHER_MODE_CBC) {
            encrypted = aes_cbc_encrypt(test_data_15, 15, key, iv, &encrypted_len);
        } else if (mode == CIPHER_MODE_CFB) {
            encrypted = aes_cfb_encrypt(test_data_15, 15, key, iv, &encrypted_len);
        } else if (mode == CIPHER_MODE_OFB) {
            encrypted = aes_ofb_encrypt(test_data_15, 15, key, iv, &encrypted_len);
        } else if (mode == CIPHER_MODE_CTR) {
            encrypted = aes_ctr_encrypt(test_data_15, 15, key, iv, &encrypted_len);
        }
    } else {
        // ECB mode
        encrypted = aes_ecb_encrypt(test_data_15, 15, key, &encrypted_len);
    }
    
    assert(encrypted != NULL);
    
    // Decrypt
    if (requires_iv) {
        decrypted = NULL;
        if (mode == CIPHER_MODE_CBC) {
            decrypted = aes_cbc_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
        } else if (mode == CIPHER_MODE_CFB) {
            decrypted = aes_cfb_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
        } else if (mode == CIPHER_MODE_OFB) {
            decrypted = aes_ofb_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
        } else if (mode == CIPHER_MODE_CTR) {
            decrypted = aes_ctr_decrypt(encrypted, encrypted_len, key, iv, &decrypted_len);
        }
    } else {
        // ECB mode
        decrypted = aes_ecb_decrypt(encrypted, encrypted_len, key, &decrypted_len);
    }
    
    assert(decrypted != NULL);
    assert(decrypted_len == 15);
    assert(memcmp(test_data_15, decrypted, 15) == 0);
    
    free(encrypted);
    free(decrypted);
    
    printf("‚úì\n");
}

int main() {
    printf("=== CryptoCore Round-trip Tests ===\n\n");
    
    test_roundtrip_mode("ECB", CIPHER_MODE_ECB, 0);
    test_roundtrip_mode("CBC", CIPHER_MODE_CBC, 1);
    test_roundtrip_mode("CFB", CIPHER_MODE_CFB, 1);
    test_roundtrip_mode("OFB", CIPHER_MODE_OFB, 1);
    test_roundtrip_mode("CTR", CIPHER_MODE_CTR, 1);
    
    printf("\n=== All round-trip tests passed! ===\n");
    return 0;
}


====================================================================
–§–ê–ô–õ: ./tests/openssl_safe_test.sh
====================================================================
#!/bin/bash

echo "=== OPENSSL SAFE TEST (–±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤) ==="

BIN="../bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"

# –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è OpenSSL —Ç–µ—Å—Ç–æ–≤
mkdir -p openssl_temp
cd openssl_temp

# –ö–æ–ø–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
cp ../test_files/test_16_bytes.txt .

echo "–¢–µ—Å—Ç–∏—Ä—É—é ECB —Å OpenSSL..."
# –®–∏—Ñ—Ä—É–µ–º CryptoCore
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_16_bytes.txt -output cc_ecb.enc

# –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å OpenSSL
if openssl enc -aes-128-ecb -d -K $KEY_HEX -in cc_ecb.enc -out openssl_ecb.dec -nopad 2>/dev/null; then
    if diff test_16_bytes.txt openssl_ecb.dec > /dev/null; then
        echo "‚úÖ ECB: CryptoCore -> OpenSSL –†–ê–ë–û–¢–ê–ï–¢"
    else
        echo "‚ùå ECB: CryptoCore -> OpenSSL –ù–ï –†–ê–ë–û–¢–ê–ï–¢ - —Ñ–∞–π–ª—ã –æ—Ç–ª–∏—á–∞—é—Ç—Å—è"
        echo "–û—Ä–∏–≥–∏–Ω–∞–ª: $(xxd -l 16 test_16_bytes.txt)"
        echo "OpenSSL:  $(xxd -l 16 openssl_ecb.dec)"
    fi
else
    echo "‚ùå ECB: OpenSSL –Ω–µ —Å–º–æ–≥ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å"
fi

echo
echo "–¢–µ—Å—Ç–∏—Ä—É—é CBC —Å OpenSSL..."
# –®–∏—Ñ—Ä—É–µ–º CryptoCore
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_16_bytes.txt -output cc_cbc.enc

# –ò–∑–≤–ª–µ–∫–∞–µ–º IV
dd if=cc_cbc.enc of=iv.bin bs=16 count=1 status=none 2>/dev/null
dd if=cc_cbc.enc of=ciphertext.bin bs=16 skip=1 status=none 2>/dev/null

if [ -f iv.bin ] && [ -f ciphertext.bin ]; then
    IV_HEX=$(xxd -p iv.bin | tr -d '\n')
    
    if openssl enc -aes-128-cbc -d -K $KEY_HEX -iv $IV_HEX -in ciphertext.bin -out openssl_cbc.dec -nopad 2>/dev/null; then
        if diff test_16_bytes.txt openssl_cbc.dec > /dev/null; then
            echo "‚úÖ CBC: CryptoCore -> OpenSSL –†–ê–ë–û–¢–ê–ï–¢"
        else
            echo "‚ùå CBC: CryptoCore -> OpenSSL –ù–ï –†–ê–ë–û–¢–ê–ï–¢ - —Ñ–∞–π–ª—ã –æ—Ç–ª–∏—á–∞—é—Ç—Å—è"
        fi
    else
        echo "‚ùå CBC: OpenSSL –Ω–µ —Å–º–æ–≥ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å"
    fi
else
    echo "‚ùå CBC: –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å IV –∏–ª–∏ —à–∏—Ñ—Ä—Ç–µ–∫—Å—Ç"
fi

# –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∏ –æ—á–∏—â–∞–µ–º
cd ..
rm -rf openssl_temp

echo "=== OPENSSL –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù ==="



====================================================================
–§–ê–ô–õ: ./tests/padding_test.sh
====================================================================
#!/bin/bash

# Padding Test Script

echo "=== Padding Test ==="

BIN="../bin/cryptocore"
KEY="@00112233445566778899aabbccddeeff"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    exit 1
fi

mkdir -p padding_test
cd padding_test

# Create test files of different sizes
echo -n "15_bytes_____" > "15.txt"  # 15 bytes
echo -n "16_bytes_______" > "16.txt"  # 16 bytes  
echo -n "17_bytes________" > "17.txt"  # 17 bytes
echo -n "31_bytes_______________________" > "31.txt"  # 31 bytes
echo -n "32_bytes______________________________" > "32.txt"  # 32 bytes

echo "Testing padding for different file sizes..."

for file in 15.txt 16.txt 17.txt 31.txt 32.txt; do
    size=$(stat -c%s "$file")
    echo "File: $file ($size bytes)"
    
    # Test ECB (requires padding)
    if "$BIN" -algorithm aes -mode ecb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.ecb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode ecb -decrypt -key "$KEY" -input "${file%.txt}.ecb.enc" -output "${file%.txt}.ecb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.ecb.dec" > /dev/null; then
            echo "  ‚úì ECB padding OK"
        else
            echo "  ‚úó ECB padding FAILED"
        fi
    else
        echo "  ‚úó ECB padding FAILED - encryption/decryption error"
    fi
    
    # Test CBC (requires padding)
    if "$BIN" -algorithm aes -mode cbc -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cbc.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cbc -decrypt -key "$KEY" -input "${file%.txt}.cbc.enc" -output "${file%.txt}.cbc.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cbc.dec" > /dev/null; then
            echo "  ‚úì CBC padding OK"
        else
            echo "  ‚úó CBC padding FAILED"
        fi
    else
        echo "  ‚úó CBC padding FAILED - encryption/decryption error"
    fi
    
    # Test CFB (no padding)
    if "$BIN" -algorithm aes -mode cfb -encrypt -key "$KEY" -input "$file" -output "${file%.txt}.cfb.enc" 2>/dev/null && \
       "$BIN" -algorithm aes -mode cfb -decrypt -key "$KEY" -input "${file%.txt}.cfb.enc" -output "${file%.txt}.cfb.dec" 2>/dev/null; then
        if diff "$file" "${file%.txt}.cfb.dec" > /dev/null; then
            echo "  ‚úì CFB no-padding OK"
        else
            echo "  ‚úó CFB no-padding FAILED"
        fi
    else
        echo "  ‚úó CFB no-padding FAILED - encryption/decryption error"
    fi
    
    echo ""
done

cd ..
rm -rf padding_test

echo "=== Padding Test Complete ==="


====================================================================
–§–ê–ô–õ: ./tests/run_nist_tests.sh
====================================================================
#!/bin/bash

echo "=== NIST Statistical Test Suite Runner ==="

# Check if NIST STS is available
NIST_DIR="../sts-2.1.2"
NIST_BIN="$NIST_DIR/assess"

if [ ! -f "$NIST_BIN" ]; then
    echo "Error: NIST STS not found at $NIST_DIR"
    echo "Please download and compile NIST STS first:"
    echo "1. Download from https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"
    echo "2. Extract to sts-2.1.2 directory in project root"
    echo "3. Run 'make' in the sts-2.1.2 directory"
    echo ""
    echo "For now, we'll generate the test data for manual NIST testing."
    echo "You can run NIST tests later when you install the test suite."
fi

echo "Generating test data for NIST..."
./bin/test_csprng

TEST_DATA="nist_test_data.bin"
if [ ! -f "$TEST_DATA" ]; then
    echo "Error: Failed to generate test data"
    exit 1
fi

echo "‚úì Test data ready: $TEST_DATA ($(stat -c%s "$TEST_DATA") bytes)"

if [ -f "$NIST_BIN" ]; then
    echo "Running NIST Statistical Test Suite..."
    cd "$NIST_DIR"

    # Create assessment configuration
    cat > assess_config.txt << EOF
../$TEST_DATA
0
1
1000000
EOF

    ./assess 1000000 < assess_config.txt

    echo ""
    echo "=== NIST Tests Complete ==="
    echo "Results available in: $NIST_DIR/experiments/AlgorithmTesting/finalAnalysisReport.txt"
    echo "Summary of results:"

    # Extract and display summary
    if [ -f "experiments/AlgorithmTesting/finalAnalysisReport.txt" ]; then
        grep -E "(TEST|passed|failed)" "experiments/AlgorithmTesting/finalAnalysisReport.txt" | head -20
    fi
else
    echo ""
    echo "=== NIST Test Data Generated ==="
    echo "Test file: $TEST_DATA"
    echo "To run full NIST tests:"
    echo "1. Download NIST STS from: https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software"
    echo "2. Extract and compile: tar -xzf sts-2.1.2.tar.gz && cd sts-2.1.2 && make"
    echo "3. Run: ./assess 1000000"
    echo "4. Use $TEST_DATA as input when prompted"
fi


====================================================================
–§–ê–ô–õ: ./tests/test_roundtrip.sh
====================================================================
#!/bin/bash

# CryptoCore Round-trip Test Script
# Tests encryption and decryption for all modes

set -e

echo "=== CryptoCore Round-trip Tests ==="
echo

BIN_PATH="../bin/cryptocore"
TEST_DIR="test_files"
KEY="@00112233445566778899aabbccddeeff"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if binary exists
if [ ! -f "$BIN_PATH" ]; then
    echo -e "${RED}Error: cryptocore binary not found at $BIN_PATH${NC}"
    echo "Please build the project first using 'make'"
    exit 1
fi

# Create test directory if it doesn't exist
mkdir -p "$TEST_DIR"

# Create test files
echo "Creating test files..."
echo "This is a test file for CryptoCore." > "$TEST_DIR/test1.txt"
echo "Another test file with different content." > "$TEST_DIR/test2.txt"

# Generate a binary test file
head -c 100 /dev/urandom > "$TEST_DIR/test3.bin"

# Test function
test_mode() {
    local mode=$1
    local input_file="$TEST_DIR/test1.txt"
    local encrypted_file="$TEST_DIR/test1.$mode.enc"
    local decrypted_file="$TEST_DIR/test1.$mode.dec"
    
    echo "Testing $mode mode..."
    
    # Encrypt
    if ! "$BIN_PATH" -algorithm aes -mode "$mode" -encrypt -key "$KEY" -input "$input_file" -output "$encrypted_file" 2>/dev/null; then
        echo -e "${RED}FAIL: Encryption failed for $mode${NC}"
        return 1
    fi
    
    # Check if encrypted file was created
    if [ ! -f "$encrypted_file" ]; then
        echo -e "${RED}FAIL: Encrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Decrypt
    if [ "$mode" = "ecb" ]; then
        # ECB mode - no IV handling
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    else
        # For other modes, IV is read from file automatically
        if ! "$BIN_PATH" -algorithm aes -mode "$mode" -decrypt -key "$KEY" -input "$encrypted_file" -output "$decrypted_file" 2>/dev/null; then
            echo -e "${RED}FAIL: Decryption failed for $mode${NC}"
            return 1
        fi
    fi
    
    # Check if decrypted file was created
    if [ ! -f "$decrypted_file" ]; then
        echo -e "${RED}FAIL: Decrypted file not created for $mode${NC}"
        return 1
    fi
    
    # Compare
    if diff "$input_file" "$decrypted_file" > /dev/null 2>&1; then
        echo -e "${GREEN}PASS: $mode round-trip successful${NC}"
        # Clean up test files for this mode
        rm -f "$encrypted_file" "$decrypted_file"
        return 0
    else
        echo -e "${RED}FAIL: $mode round-trip failed - files differ${NC}"
        echo "Input file size: $(stat -c%s "$input_file") bytes"
        echo "Decrypted file size: $(stat -c%s "$decrypted_file") bytes"
        return 1
    fi
}

# Test all modes
modes=("ecb" "cbc" "cfb" "ofb" "ctr")
passed=0
total=0

echo "Starting round-trip tests..."
echo

for mode in "${modes[@]}"; do
    if test_mode "$mode"; then
        ((passed++))
    else
        # Debug info for failed test
        echo "Debug info for $mode:"
        ls -la "$TEST_DIR"/test1.$mode.* 2>/dev/null || echo "No test files found"
    fi
    ((total++))
    echo
done

# Clean up original test files
rm -f "$TEST_DIR"/test1.txt "$TEST_DIR"/test2.txt "$TEST_DIR"/test3.bin

echo "=== Test Summary ==="
echo "Passed: $passed/$total"

if [ $passed -eq $total ]; then
    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
else
    echo -e "${RED}Some tests failed!${NC}"
    exit 1
fi


====================================================================
–§–ê–ô–õ: ./tests/test_files/test_16.txt
====================================================================
0123456789ABCDEF



====================================================================
–§–ê–ô–õ: ./tests/test_files/test_16_bytes.txt
====================================================================
0123456789ABCDEF



====================================================================
–§–ê–ô–õ: ./tests/test_files/debug_test.txt
====================================================================
Hello, CryptoCore! This is a test.



====================================================================
–§–ê–ô–õ: ./tests/test_files/test1.txt
====================================================================
This is a test file for CryptoCore.



====================================================================
–§–ê–ô–õ: ./tests/test_files/test2.txt
====================================================================
Another test file with different content.



====================================================================
–§–ê–ô–õ: ./tests/test_files/test_15_bytes.txt
====================================================================
15_bytes_____


====================================================================
–§–ê–ô–õ: ./run_tests.sh
====================================================================
#!/bin/bash

echo "=== CryptoCore Comprehensive Tests ==="

BIN="./bin/cryptocore"
KEY_HEX="00112233445566778899aabbccddeeff"
KEY="@$KEY_HEX"

# Check if binary exists
if [ ! -f "$BIN" ]; then
    echo "ERROR: cryptocore binary not found at $BIN"
    echo "Please build the project first using 'make'"
    exit 1
fi

echo "‚úì Binary found: $BIN"

# Create test files
echo "Creating test files..."
echo "0123456789ABCDEF" > test_16.txt  # 16 bytes - no padding needed
echo "Test message for padding check" > test_text.txt  # Will need padding

echo "=== Test 1: Round-trip Tests ==="
for mode in ecb cbc cfb ofb ctr; do
    echo "Testing $mode..."
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input test_16.txt -output test_$mode.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input test_$mode.enc -output test_$mode.dec
    
    if diff test_16.txt test_$mode.dec > /dev/null; then
        echo "  ‚úÖ $mode round-trip PASSED"
    else
        echo "  ‚ùå $mode round-trip FAILED"
    fi
done

echo ""
echo "=== Test 2: OpenSSL Interoperability ==="

# ECB test
echo "Testing ECB interoperability..."
$BIN -algorithm aes -mode ecb -encrypt -key $KEY -input test_16.txt -output cc_ecb.enc
openssl enc -aes-128-ecb -d -K $KEY_HEX -in cc_ecb.enc -out os_ecb.dec -nopad 2>/dev/null

if diff test_16.txt os_ecb.dec > /dev/null; then
    echo "  ‚úÖ ECB interoperability PASSED"
else
    echo "  ‚ùå ECB interoperability FAILED"
fi

# CBC test  
echo "Testing CBC interoperability..."
$BIN -algorithm aes -mode cbc -encrypt -key $KEY -input test_16.txt -output cc_cbc.enc
dd if=cc_cbc.enc of=iv.bin bs=16 count=1 status=none 2>/dev/null
dd if=cc_cbc.enc of=ciphertext.bin bs=16 skip=1 status=none 2>/dev/null
IV_HEX=$(xxd -p iv.bin 2>/dev/null | tr -d '\n')
openssl enc -aes-128-cbc -d -K $KEY_HEX -iv $IV_HEX -in ciphertext.bin -out os_cbc.dec -nopad 2>/dev/null

if diff test_16.txt os_cbc.dec > /dev/null; then
    echo "  ‚úÖ CBC interoperability PASSED"
else
    echo "  ‚ùå CBC interoperability FAILED"
fi

echo ""
echo "=== Test 3: Padding Tests ==="
for mode in ecb cbc; do
    echo "Testing $mode with padding..."
    $BIN -algorithm aes -mode $mode -encrypt -key $KEY -input test_text.txt -output pad_$mode.enc
    $BIN -algorithm aes -mode $mode -decrypt -key $KEY -input pad_$mode.enc -output pad_$mode.dec
    
    if diff test_text.txt pad_$mode.dec > /dev/null; then
        echo "  ‚úÖ $mode padding PASSED"
    else
        echo "  ‚ùå $mode padding FAILED"
    fi
done

# Cleanup
echo "Cleaning up..."
rm -f test_*.txt test_*.enc test_*.dec cc_*.enc os_*.dec iv.bin ciphertext.bin pad_*.enc pad_*.dec

echo ""
echo "=== ALL TESTS COMPLETED ==="



====================================================================
–§–ê–ô–õ: ./test_plain.txt
====================================================================
Hello, this is a test file for CryptoCore!
